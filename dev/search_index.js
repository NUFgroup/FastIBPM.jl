var documenterSearchIndex = {"docs":
[{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/#FastIBPM.nonlinear!","page":"Operators","title":"FastIBPM.nonlinear!","text":"nonlinear!(nonlin, u, ω)\n\nCompute the nonlinear advection term in-place.\n\nThis function updates the nonlinear term array nonlin by evaluating the nonlinear contribution at every grid point, based on the velocity field u and the vorticity field ω. It represents the convective term the convective term (u · ∇)u = u × ω for incompressible flow.\n\nThe computation is parallelized over the grid using the appropriate backend (e.g. CPU or GPU).\n\nArguments\n\nnonlin: array (or array of arrays) storing the nonlinear term; modified in place.\nu: velocity field.\nω: vorticity field.\n\nReturns\n\nThe updated nonlin field.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.nonlinear","page":"Operators","title":"FastIBPM.nonlinear","text":"nonlinear(i, u, ω, I)\n\nCompute the nonlinear advection term for component i at grid point I.\n\nThis function evaluates the local contribution of the nonlinear term the i-th component of the cross product u × ω computed using bilinear interpolation of the velocity and vorticity fields. velocity and vorticity fields. It is called internally by nonlinear!.\n\nArguments\n\ni: index of the velocity component being computed.\nu: velocity field.\nω: vorticity field.\nI: Cartesian grid index.\n\nReturns\n\nThe scalar nonlinear term at the specified component and grid location.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.rot!","page":"Operators","title":"FastIBPM.rot!","text":"rot!(ω, u; h)\n\nCompute the vorticity field ω from the velocity field u in-place.\n\nArguments\n\nω: Array of arrays where the computed vorticity components will be stored (mutated in-place).\nu: Array of arrays representing the velocity field.\nh: Grid spacing used for finite-difference approximation of the curl (keyword argument).\n\nDescription\n\nThis function updates ω directly by looping over each component and grid index, calling rot(i, u, I; h) for each point.   The computation is parallelized using the available backend (CPU or GPU) for efficiency.\n\nReturns\n\nω: The updated vorticity field (same array as input, modified in-place).\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.rot","page":"Operators","title":"FastIBPM.rot","text":"rot(i, u, I; h)\n\nCompute the i-th component of the vorticity (curl) at a single grid point I from a velocity field u.\n\nArguments\n\ni: Index of the vorticity component to compute (e.g., 1 for x, 2 for y).\nu: Array of arrays representing the velocity field.\nI: Cartesian index of the grid point where the curl is computed.\nh: Grid spacing used for finite-difference approximation.\n\nReturns\n\nScalar value representing the i-th component of the vorticity at point I.\n\nNotes\n\nThis function computes the curl at a single point. To compute the full vorticity field over the grid, use rot!(ω, u; h), which applies rot in-place across all grid points.\nThe function uses finite differences and cross-product indexing (sumcross) to compute the curl:\n\n(∇ × u)i = sum{(j,k)} (uk[I] - uk[I-δ(j)]) / h.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.curl!","page":"Operators","title":"FastIBPM.curl!","text":"curl!(u, ψ; h)\n\nCompute the velocity field u as the curl of a potential field ψ over the entire grid.\n\nArguments\n\nu: Array of arrays representing the velocity field (updated in-place).\nψ: Array of arrays representing the potential field.\nh: Grid spacing used for finite-difference approximation.\n\nReturns\n\nThe updated velocity field u.\n\nNotes\n\nThis function applies the curl computation at every grid point in-place.\nIt uses finite differences and the helper function curl(i, ψ, I; h) to compute each component.\nThe backend is automatically chosen for parallel or GPU execution.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.curl","page":"Operators","title":"FastIBPM.curl","text":"curl(i, ψ, I; h)\n\nCompute the i-th component of a velocity field as the curl of a scalar potential ψ at a specific grid point.\n\nArguments\n\ni: Index of the velocity component to compute (e.g., 1 for x, 2 for y).\nψ: Array of arrays representing the scalar potential field.\nI: Cartesian index of the grid point where the curl is evaluated.\nh: Grid spacing used for finite-difference approximation.\n\nReturns\n\nA scalar value representing the i-th component of the curl at grid point I.\n\nNotes\n\nThe result is divergence-free by construction.\nUses centered finite differences and sumcross to handle component indices.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.LaplacianPlan","page":"Operators","title":"FastIBPM.LaplacianPlan","text":"struct LaplacianPlan\n\nHolds the data required to compute the Laplacian efficiently in spectral space using FFTs.\n\nFields\n\nλ: eigenvalues of the Laplacian for spectral multiplication.\nwork: temporary workspace array.\nfwd: forward FFT plan.\ninv: inverse FFT plan.\nn_logical: logical size of the FFT domain.\n\nConstructor\n\nLaplacianPlan(ω_i, i, n)\n\nCreates a LaplacianPlan for a given field component ω_i on a grid of size n (e.g., SVector(nx, ny)).\n\nArguments\n\nω_i: array representing one component of the field (e.g., vorticity).\ni: component index (1, 2, or 3 for x, y, z).\nn: grid resolution as SVector{N}.\n\nReturns\n\nA LaplacianPlan struct containing all data needed to:\nTransform the field to spectral space.\nMultiply by Laplacian eigenvalues.\nTransform back to physical space.\n\nNotes\n\nThe constructor sets up FFT plans (fwd and inv) and eigenvalues (λ) automatically.\nThe Laplacian is then applied as Δu ≈ λ .* fwd(u).\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM.laplacian_fft_kind","page":"Operators","title":"FastIBPM.laplacian_fft_kind","text":"laplacian_fft_kind(i, nd)\n\nReturn a tuple specifying the FFT type to use along each dimension of a multidimensional array for the Laplacian operator.\n\nArguments\n\ni: The dimension index that should use a cosine transform (FFTW.REDFT01).\nnd: Total number of dimensions of the array.\n\nReturns\n\nA tuple of length nd with FFTW.REDFT01 for dimension i and FFTW.RODFT00 for all other dimensions.\n\nNotes\n\nREDFT01 (DCT-I) is typically used for Neumann or periodic boundary conditions.\nRODFT00 (DST-I) is typically used for Dirichlet (zero-value) boundary conditions.\t\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.laplacian_eigvals!","page":"Operators","title":"FastIBPM.laplacian_eigvals!","text":"laplacian_eigvals!(λ, i)\n\nCompute the eigenvalues of the discrete Laplacian on a multidimensional grid and store them in λ.\n\nArguments\n\nλ: Array to hold the eigenvalues (modified in-place)\ni: The dimension index along which the cosine transform (DCT) is applied; other dimensions use sine transforms (DST)\n\nReturns\n\nThe array λ filled with Laplacian eigenvalues\n\nNotes\n\nThe computation runs in parallel on the backend associated with λ\nEigenvalues correspond to the discrete Laplacian under DCT (dimension i) and DST (other dimensions)\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.laplacian_plans","page":"Operators","title":"FastIBPM.laplacian_plans","text":"laplacian_plans(ω, n)\n\nCreate a Laplacian plan for each component of a vector field ω.\n\nArguments\n\nω: Vector field whose components require Laplacian plans\nn: Grid resolution (e.g., tuple of (nx, ny) or (nx, ny, nz))\n\nReturns\n\nA tuple of LaplacianPlan objects, one for each component of ω\n\nNotes\n\nEach LaplacianPlan contains the eigenvalues and FFT plans needed for spectral Poisson solvers\nUseful when different components require different FFT types due to mixed boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.EigenbasisTransform","page":"Operators","title":"FastIBPM.EigenbasisTransform","text":"EigenbasisTransform\n\nRepresents a spectral transform that applies a function f (e.g., inverse Laplacian) in the eigenbasis of the Laplacian. It uses precomputed Laplacian plans to efficiently apply forward and inverse FFTs, multiply by f(λ) in spectral space, and transform back.\n\nFields\n\nf: Function or scalar applied to the eigenvalues.\nplan: Tuple of LaplacianPlan objects wrapped in an OffsetTuple for staggered grid alignment.\n\nConstructor\n\nEigenbasisTransform(f, plans::Tuple) wraps a regular tuple of LaplacianPlan objects into an OffsetTuple automatically.  This allows you to pass a standard tuple without needing to manually construct an OffsetTuple.\n\nCall Overloads\n\n(X::EigenbasisTransform)(y, ω) applies the transform to all components of ω, storing the result in y.\n(X::EigenbasisTransform)(yᵢ, ωᵢ, i) applies the transform to the i-th component using its corresponding Laplacian plan.  \n\nNotes\n\nUseful for spectral Poisson solvers and other operations in the Laplacian eigenbasis.\nThe OffsetTuple ensures proper alignment for staggered grid variables.\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM._coarse_indices","page":"Operators","title":"FastIBPM._coarse_indices","text":"_coarse_indices(n::NTuple{N}, loc::Edge{Dual}) where {N}\n\nCompute the index ranges for a coarser grid that is a subset of the original grid.\n\nDescription\n\nThis function determines which indices to retain when coarsening a field defined on edges of the dual grid.   It is used in multigrid methods to identify the portion of the grid that remains after reducing resolution.\n\nArguments\n\nn: Tuple giving the number of grid points in each dimension.\nloc: Specifies the edge location in the dual grid.\n\nReturns\n\nA tuple of index ranges corresponding to the coarse grid coordinates.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.multidomain_coarsen!","page":"Operators","title":"FastIBPM.multidomain_coarsen!","text":"multidomain_coarsen!(ω², ω¹; n)\n\nCoarsen a fine-grid field ω¹ into a coarser field ω² for use in multigrid solvers.\n\nDescription\n\nThis function reduces the resolution of each component of a vector field by averaging fine-grid values into the coarser grid using a restriction stencil.   It runs in parallel across the computational backend and relies on _coarse_indices and multidomain_coarsen for index mapping and averaging.\n\nArguments\n\nω²: Output field on the coarser grid.\nω¹: Input field on the finer grid.\nn: Tuple giving the grid resolution.\n\nReturns\n\nThe coarsened field ω².\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.multidomain_coarsen","page":"Operators","title":"FastIBPM.multidomain_coarsen","text":"multidomain_coarsen(i, ωᵢ, I²; n)\n\nCompute the coarse-grid value of a field component from its fine-grid representation.\n\nDescription\n\nFor component i, this function calculates the value at coarse-grid index I² by averaging corresponding fine-grid points using a predefined stencil.   It is used internally by multidomain_coarsen! to define the restriction operation.\n\nArguments\n\ni: Component index.\nωᵢ: Fine-grid array for the given component.\nI²: Cartesian index on the coarse grid.\nn: Tuple giving the grid resolution.\n\nReturns\n\nThe coarse-grid value at index I².\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM._coarsen_stencil","page":"Operators","title":"FastIBPM._coarsen_stencil","text":"_coarsen_stencil(T)\n\nReturn a normalized 3×3 smoothing stencil used for grid coarsening.\n\nDescription\n\nThis function defines a weighted averaging kernel for use in multigrid coarsening or smoothing operations.   It produces a static 3×3 matrix from StaticArrays.jl with higher weight at the center and symmetric lower weights around it.   The entries sum to 1, ensuring mass conservation during coarsening.\n\nArguments\n\nT: Element type of the output matrix.\n\nReturns\n\nA 3×3 static matrix of type T used as a normalized coarsening stencil.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM._fine_indices","page":"Operators","title":"FastIBPM._fine_indices","text":"_fine_indices(i, n, I)\n\nReturn the fine-grid indices corresponding to a coarse-grid index I.\n\nDescription\n\nThis function identifies which fine-grid cells map to a given coarse-grid location, used for coarsening or restriction in multigrid solvers.   It supports both 2D and 3D cases:\n\nIn 2D, it returns a single CartesianIndices range.\nIn 3D, it returns two CartesianIndices planes associated with the selected component i.\n\nArguments\n\ni: Component index (used only in 3D).\nn: Tuple representing the grid size.\nI: Coarse-grid index tuple.\n\nReturns\n\nA tuple of one or more CartesianIndices objects representing fine-grid regions corresponding to the coarse-grid index I.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM._fine_range","page":"Operators","title":"FastIBPM._fine_range","text":"_fine_range(n, I)\n\nReturn the range of fine-grid indices corresponding to a coarse-grid index I along one dimension.\n\nDescription\n\nMaps a 1D coarse-grid index to the corresponding three-point region on the fine grid, assuming a 4:1 refinement ratio.   The range is centered around 2 * (I - n/4) and includes the neighboring points at offsets -1, 0, and +1.\n\nArguments\n\nn: Grid size along the considered dimension.\nI: Coarse-grid index.\n\nReturns\n\nA UnitRange of three fine-grid indices corresponding to the coarse-grid index I.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.multidomain_interpolate!","page":"Operators","title":"FastIBPM.multidomain_interpolate!","text":"multidomain_interpolate!(ωb, ω; n)\n\nInterpolate a fine-grid field ω onto boundary or ghost regions, storing results in ωb.\n\nDescription\n\nThis function computes interpolated boundary values from a fine-grid field ω and writes them into the corresponding boundary arrays ωb.   It supports both 2D and 3D cases and calls the helper function [multidomain_interpolate] for the actual interpolation logic.\n\nArguments\n\nωb: Output array for interpolated boundary values.\nω: Input fine-grid field (e.g., vorticity).\nn: Grid size tuple, used for mapping fine-to-coarse indices.\n\nReturns\n\nThe updated ωb containing interpolated boundary values.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.multidomain_interpolate","page":"Operators","title":"FastIBPM.multidomain_interpolate","text":"multidomain_interpolate(ωᵢ, (i, j, k), dir, I¹; n)\n\nInterpolate values from a fine grid onto a coarser grid or boundary face.\n\nDescription\n\nDefines the interpolation rule used by [multidomain_interpolate!].   Two methods are available:\n\n2D version (CartesianIndex{2}): performs simple linear interpolation along one direction.\n3D version (CartesianIndex{3}): performs bilinear interpolation on a 2D plane, adjusting for component offsets.\n\nArguments\n\nωᵢ: Component i of the fine-grid field.\n(i, j, k): Index tuple defining component and orientation.\ndir: Direction index for boundary interpolation.\nI¹: Fine-grid index at which interpolation is performed.\nn: Grid size tuple.\n\nReturns\n\nInterpolated scalar value for the target coarse-grid or boundary location.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.set_boundary!","page":"Operators","title":"FastIBPM.set_boundary!","text":"set_boundary!(ω, ωb)\n\nCopy boundary values from a boundary buffer ωb into the main field ω.\n\nDescription\n\nThis function updates the field ω by setting its boundary regions to the corresponding values stored in ωb.   It is typically used after interpolation or restriction steps in multigrid or multidomain solvers to enforce consistent boundary conditions.\n\nThe operation is performed in parallel using backend-agnostic loops.\n\nArguments\n\nω: Main field to be updated (e.g., vorticity or velocity component arrays).\nωb: Boundary buffer containing precomputed boundary values for each component of ω.\n\nReturns\n\nThe modified field ω with updated boundary values.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.add_laplacian_bc!","page":"Operators","title":"FastIBPM.add_laplacian_bc!","text":"add_laplacian_bc!(Lψ, factor, ψb)\n\nApply boundary condition corrections to the Laplacian of a vector field.\n\nDescription\n\nThis function modifies the Laplacian Lψ of a field by adding contributions from boundary values in ψb.   It ensures that Dirichlet or Neumann boundary conditions are correctly enforced in the discrete Laplacian.\n\nArguments\n\nLψ: Vector of arrays representing the Laplacian of the field ψ.\nfactor: Scalar multiplier for the boundary corrections.\nψb: Boundary buffer holding Dirichlet or Neumann values at the domain boundaries.\n\nReturns\n\nThe modified Lψ with boundary corrections applied (in-place).\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.laplacian_bc_ii","page":"Operators","title":"FastIBPM.laplacian_bc_ii","text":"laplacian_bc_ii(ψb, i, dir, I)\n\nCompute the diagonal Laplacian boundary correction for component i.\n\nDescription\n\nThis function calculates the correction term for the Laplacian at a boundary along direction dir for the i-th component.   It uses differences of precomputed boundary values in ψb to enforce proper boundary conditions in the discrete Laplacian operator.\n\nArguments\n\nψb: Boundary buffer arrays for each component and direction.\ni: Index of the component being corrected.\ndir: Direction of the boundary (e.g., 1 = x, 2 = y, 3 = z).\nI: Cartesian index in the boundary array where the correction is computed.\n\nReturns\n\nA scalar value representing the diagonal Laplacian boundary correction at the given index.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.multidomain_poisson!","page":"Operators","title":"FastIBPM.multidomain_poisson!","text":"multidomain_poisson!(ω, ψ, u, ψb, grid, fft_plan)\n\nSolve Poisson equations across multiple grid levels using a multigrid-like approach.\n\nDescription\n\nThis function computes the solution of Poisson problems on a hierarchical set of grids.   It performs the following steps for each level:\n\nCoarsen the source term ω from finer to coarser grids.\nSolve from coarse to fine.\nOptionally compute the velocity field u at selected levels using curl!.\n\nArguments\n\nω: Vector of vector fields representing source terms at each grid level.\nψ: Vector of potential fields to store the solution at each level.\nu: Vector of velocity fields to update via curl of ψ.\nψb: Boundary buffers for the potential fields.\ngrid: Grid object containing the domain size and level information.\nfft_plan: Precomputed EigenbasisTransform plans for spectral solves.\n\nReturns\n\nThe function updates ψ and u in-place with the Poisson solution and velocity field.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.AbstractDeltaFunc","page":"Operators","title":"FastIBPM.AbstractDeltaFunc","text":"AbstractDeltaFunc\n\nAbstract type for delta-function-like objects. Subtypes define specific delta kernels.\n\nUsage\n\nA delta function can be called on a vector r to evaluate the multidimensional delta:\n\ndelta(r)  # evaluates as the product of 1D delta values along each component\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM.DeltaYang3S","page":"Operators","title":"FastIBPM.DeltaYang3S","text":"DeltaYang3S <: AbstractDeltaFunc\n\nSmooth delta function approximation with compact support [-2, 2], following Yang et al. (2009).\n\nsupport(::DeltaYang3S) = 2 gives its support radius.\nCalling delta(r::Real) evaluates the function at a real point r using a piecewise formula:\n|r| < 1 → first formula\n1 ≤ |r| < 2 → second formula\n|r| ≥ 2 → returns 0\n\nThe function is smooth and satisfies partition-of-unity and moment conditions.\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM.DeltaYang3S2","page":"Operators","title":"FastIBPM.DeltaYang3S2","text":"DeltaYang3S2 <: AbstractDeltaFunc\n\nSmoother and wider delta function than DeltaYang3S, with compact support [-3, 3].\n\nsupport(::DeltaYang3S2) = 3 gives its support radius.\nCalling delta(x::Real) evaluates the function at x using piecewise formulas:\nr ≤ 1\n1 < r ≤ 2\n2 < r ≤ 3\nr > 3 → 0\n\nEach segment uses polynomials, square roots, and arcsine terms to ensure smoothness and correct moment conditions.\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM.Reg","page":"Operators","title":"FastIBPM.Reg","text":"Reg{D,T,N,A,M,W}\nReg(backend, T, delta, nb, Val{N})\n\nRepresents a regularization operator used for interpolation and spreading based on a discrete delta function.\n\nFields\n\ndelta — the regularized delta function (a subtype of AbstractDeltaFunc).\nI — a matrix of index offsets defining the discrete stencil.\nweights — preallocated delta weights for each stencil point.\n\nThe struct is adapted for GPU execution via Adapt.@adapt_structure, allowing Reg objects to be transferred automatically between CPU and GPU memory.\n\nConstructor\n\nReg(backend, T, delta, nb, Val{N}) creates a regularization operator in N dimensions. It allocates:\n\nthe stencil index matrix I, and\nthe multidimensional weights array whose size is determined by the support of the delta function.\n\nbackend controls where arrays are allocated (CPU or GPU), and nb is the number of bodies or markers for which weights are stored.\n\nThis type is typically used in immersed-boundary methods for evaluating and applying discrete delta functions.\n\n\n\n\n\n","category":"type"},{"location":"operators/#FastIBPM.update_weights!","page":"Operators","title":"FastIBPM.update_weights!","text":"update_weights!(reg, grid, xbs, ibs)\n\nUpdate interpolation/spreading weights for immersed boundary markers.\n\nThis function computes the stencil indices and delta-function weights used to transfer data between Lagrangian marker positions (xbs) and the Eulerian grid (grid). Only markers listed in ibs are updated. The result is stored in-place inside the Reg object reg.\n\nArguments\n\nreg::Reg: Regularization structure containing delta kernel, stencil offsets, and a weight array to be filled.\ngrid::Grid{N}: Eulerian grid used for mapping marker positions to grid coordinates.\nxbs: Array of marker positions (typically SVector{N,Float}).\nibs: Indices of the markers to update.\n\nNotes\n\nIf ibs is empty, the function returns reg unchanged.\nFor each marker and each velocity/force component, the function:\nComputes the integer grid offset I nearest to the marker.\nIterates over all stencil points within the delta kernel’s support.\nEvaluates the delta function at normalized offsets (xb - xu) / h.\nStores the resulting weights in reg.weights.\n\nReturns\n\nReturns the updated reg.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.interpolate_body!","page":"Operators","title":"FastIBPM.interpolate_body!","text":"interpolate_body!(ub, reg, u)\n\nInterpolate the Eulerian velocity field u onto the Lagrangian marker velocities ub using precomputed regularization stencils stored in reg.\n\nThis function gathers velocity values from the Eulerian grid for each marker and each velocity component, applies the corresponding delta–function weights, and stores the resulting interpolated velocities in-place in ub.\n\nArguments\n\nub: Output array of marker velocities (e.g., Vector{SVector{N,T}}).\nreg::Reg: Regularization structure containing interpolation indices I and delta weights weights.\nu: Eulerian velocity field, given as an array of N grid arrays (u[1], u[2], …).\n\nNotes\n\nFor each marker, the function loops over velocity components and computes a weighted sum of nearby grid values using the delta kernel’s support.\nUses the precomputed stencil offsets reg.I and weight tensors reg.weights, which must be updated before calling this function.\nUpdates ub in-place and also returns it.\n\nReturns\n\nUpdates ub in-place.\n\n\n\n\n\n","category":"function"},{"location":"operators/#FastIBPM.regularize!","page":"Operators","title":"FastIBPM.regularize!","text":"regularize!(fu, reg, fb)\n\nSpread Lagrangian forces fb onto the Eulerian force field fu using the regularization stencils stored in reg.\n\nThis function distributes each marker force to nearby Eulerian grid points using the delta–function weights in reg.weights and the corresponding index offsets in reg.I. The resulting Eulerian force field is written in-place in fu.\n\nArguments\n\nfu: Output Eulerian force field, given as an array of N grids (fu[1], fu[2], …). All entries are reset to zero before accumulation.\nreg::Reg: Regularization structure containing interpolation/spreading indices I and delta weights weights.\nfb: Lagrangian forces, typically stored as Vector{SVector{N}}, one force vector per marker.\n\nNotes\n\nFor each marker, the force components are distributed over the delta kernel’s support region.\nThis operation is the adjoint (transpose) of interpolate_body! in the immersed boundary method.\nUpdates fu in-place and also returns it.\n\nReturns\n\nUpdates fu in-place.\n\n\n\n\n\n","category":"function"},{"location":"examples/#FastIBPM.jl-Example","page":"Examples","title":"FastIBPM.jl Example","text":"One example on how to run the code. The src folder contains all the necessary files to run it. More examples are provided in the examples folder.","category":"section"},{"location":"examples/#Flow-Past-a-Cylinder-(Re-200)-—-FastIBPM-Example","page":"Examples","title":"Flow Past a Cylinder (Re = 200) — FastIBPM Example","text":"This example simulates flow around a circular cylinder at Reynolds number Re = 200. \n\nA small perturbation is added to the initial vorticity field to trigger natural vortex shedding. The simulation is performed using FastIBPM.jl, and results are saved to an HDF5 file. We then visualize vorticity fields and compute lift and drag coefficients.\n\n","category":"section"},{"location":"examples/#1.-Setup","page":"Examples","title":"1. Setup","text":"Load the required packages and set up the output directory:\n\nusing FastIBPM\nusing StaticArrays\nusing ProgressMeter\nusing OffsetArrays\nusing LinearAlgebra\nusing HDF5\nusing Peaks\nusing Statistics\nusing Printf\nusing Plots\n\n# Set up output directory\nconst CASE = \"cylinder_Re200\"\nconst OUTDIR = joinpath(pwd(), \"figures\", CASE)\nmkpath(OUTDIR)\n\n","category":"section"},{"location":"examples/#2.-Grid-and-Body-Definition","page":"Examples","title":"2. Grid and Body Definition","text":"We define a multilevel grid with resolution h = 0.02 and a circular cylinder body.\n\nh = 0.02  # grid cell size\ngridlims = SA[-1.0 3.0; -2.0 2.0]\n\ngrid = Grid(;\n    h,\n    n = @.(round(Int, (gridlims[:, 2] - gridlims[:, 1]) / h)),\n    x0 = gridlims[:, 1],\n    levels = 5\n)\n\n# Cylinder definition\nr = 0.5                   # cylinder radius\nS = 2π * r                # cylinder circumference\nn_ib = round(Int, S / (2 * h))  # number of IB points\nds = S / n_ib\n\nbody = let\n    x = map(range(0, 2π, n_ib + 1)[1:end-1]) do θ\n        r * SA[cos(θ), sin(θ)]\n    end\n    StaticBody(x, fill(ds, n_ib))\nend\n\n","category":"section"},{"location":"examples/#3.-Problem-Definition","page":"Examples","title":"3. Problem Definition","text":"Define time step, Reynolds number, and freestream inflow:\n\ndt = 0.002\nRe = 200.0\n\nu0 = UniformFlow(t -> SA[1.0, 0.0])\nprob = IBProblem(grid, body, Re, u0)\n\n","category":"section"},{"location":"examples/#4.-Simulation-Loop","page":"Examples","title":"4. Simulation Loop","text":"We define the solver loop that:\n\nInitializes a CNAB solver  \nAdds a perturbation to trigger shedding  \nSteps through time  \nSaves vorticity snapshots and force data  \n\nfunction solution(file; tf, snapshot_freq)\n    T = Float64\n    sol = CNAB(prob; dt, delta=FastIBPM.DeltaYang3S2())\n\n    # Perturbation to induce vortex shedding\n    map!(sol.ω[1][3], CartesianIndices(sol.ω[1][3])) do I\n        x = coord(grid, Loc_ω(3), I)\n        p = x - SA[-0.75, 0]\n        r = 0.25\n        0.5 * (1 - clamp(norm(p) / r, 0, 1))\n    end\n    apply_vorticity!(sol)\n\n    # Setup HDF5 datasets\n    i_all = 1:1+round(Int, tf / dt)\n    n_all = length(i_all)\n    i_snapshot = i_all[1:snapshot_freq:end]\n    n_snapshot = length(i_snapshot)\n\n    all_group = create_group(file, \"all\")\n    t_all = create_dataset(all_group, \"t\", T, (n_all,))\n    Cl = create_dataset(all_group, \"Cl\", T, (n_all,))\n    Cd = create_dataset(all_group, \"Cd\", T, (n_all,))\n\n    snapshot_group = create_group(file, \"snapshots\")\n    t_snapshot = create_dataset(snapshot_group, \"t\", T, (n_snapshot,))\n    ω = create_dataset(\n        snapshot_group, \"omega\", T, (size(sol.ω[1][3])..., grid.levels, n_snapshot)\n    )\n    write_attribute(ω, \"firstindex\", collect(first.(axes(sol.ω[1][3]))))\n\n    # Time integration loop\n    @showprogress desc = \"solving\" for _ in 0:round(Int, tf / dt)\n        step!(sol)\n\n        # Compute forces (Drag = x-force, Lift = y-force)\n        f = surface_force_sum(sol)\n        t_all[sol.i] = sol.t\n        Cd[sol.i] = 2 * f[1]\n        Cl[sol.i] = 2 * f[2]\n\n        # Save snapshots\n        if sol.i in i_snapshot\n            i = 1 + (sol.i - first(i_snapshot)) ÷ step(i_snapshot)\n            t_snapshot[i] = sol.t\n            for level in eachindex(sol.ω)\n                ω[:, :, level, i] = OffsetArrays.no_offset_view(sol.ω[level][3])\n            end\n        end\n    end\nend","category":"section"},{"location":"examples/#Run-the-simulation","page":"Examples","title":"Run the simulation","text":"soln_path = joinpath(OUTDIR, \"$(CASE).h5\")\n\nif isfile(soln_path)\n    @info \"File already exists\" soln_path\nelse\n    h5open(soln_path, \"cw\") do file\n        solution(file; tf=40.0, snapshot_freq=100)\n    end\nend\n\n","category":"section"},{"location":"examples/#5.-Visualization","page":"Examples","title":"5. Visualization","text":"","category":"section"},{"location":"examples/#Vorticity-Animation","page":"Examples","title":"Vorticity Animation","text":"h5open(soln_path, \"r\") do file\n    t = read(file[\"snapshots/t\"])\n    ω = file[\"snapshots/omega\"]\n    ω_start = read_attribute(ω, \"firstindex\")\n    nx, ny, nlev, nt = size(ω)\n\n    xidx = ω_start[1]:(ω_start[1] + nx - 1)\n    yidx = ω_start[2]:(ω_start[2] + ny - 1)\n\n    ωlim = 7.5\n\n    r = 0.485\n    θ = range(0, 2π; length=400)\n    cx, cy = r .* cos.(θ), r .* sin.(θ)\n\n    anim = Animation()\n    @showprogress for i in eachindex(t)\n        p = plot(legend=false, aspect_ratio=:equal,\n             xlim=(-2,8), ylim=(-2,2), framestyle=:box)\n\n        # Draw from coarse → fine\n        for lev in nlev:-1:1\n            X, Y = coord(grid, Loc_ω(3), (xidx, yidx), lev)\n            xvec, yvec = X[:,1], Y[:,1]\n            z = ω[:, :, lev, i]\n            heatmap!(\n                xvec, yvec, z';\n                aspect_ratio=:equal, colormap=:bwr,\n                xlim=(-2,15), ylim=(-3,3),\n                clim = (-ωlim, ωlim), legend=false\n            )\n        end\n\n        plot!(Shape(cx, cy), color=:gray, lw=0)\n        title!(@sprintf(\"t = %.2f\", t[i]))\n        frame(anim, p)\n    end\n\n    gif(anim, joinpath(OUTDIR, \"$(CASE)_vorticity.gif\"), fps=30)\nend\n\n","category":"section"},{"location":"examples/#6.-Lift-and-Drag-Coefficients","page":"Examples","title":"6. Lift and Drag Coefficients","text":"results = h5open(soln_path, \"r\") do soln\n    (; t=read(soln[\"all/t\"]), Cl=read(soln[\"all/Cl\"]), Cd=read(soln[\"all/Cd\"]))\nend\n\n# Analyze steady state (skip initial transient)\ni_start = 1 + round(Int, 50 / dt)\n\npeaks = map((; Cl=results.Cl, Cd=results.Cd)) do y\n    z = @view y[Base.IdentityUnitRange(i_start:end)]\n    (findminima(z), findmaxima(z))\nend\n\noscillations = map(peaks) do p\n    (a, b) = map(x -> mean(x.heights), p)\n    ((a + b) / 2, (b - a) / 2)\nend\n\n# Plot\np = plot(legend = :topright, xlabel = \"t\", ylabel = \"\", ylims = (-2, 2),\n         framestyle = :box)\n\nfor f in (:Cl, :Cd)\n    t = results.t\n    C = results[f]\n    pks = peaks[f]              # (minima, maxima)\n    μ, A = oscillations[f]      # (mean, amplitude)\n\n    col = f == :Cl ? :blue : :red\n\n    # Trace\n    plot!(p, t, C; color=col, label=String(f))\n\n    # Peak markers\n    idx = vcat(pks[1].indices, pks[2].indices)\n    scatter!(p, t[idx], C[idx]; color=col, ms=2.5, label=\"\")\n\n    # Mean ± amplitude\n    hline!(p, [μ - A, μ + A]; color=col, linestyle=:dash, label=\"\")\nend\n\nsavefig(p, joinpath(OUTDIR, \"$(CASE)_Cl_Cd.png\"))","category":"section"},{"location":"problem_definition/#Problem-Definition","page":"Problem Definition","title":"Problem Definition","text":"","category":"section"},{"location":"problem_definition/#FastIBPM.GridKind","page":"Problem Definition","title":"FastIBPM.GridKind","text":"abstract type GridKind end\n\nAbstract type used to distinguish between different kinds of staggered grids. See Primal and Dual.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Primal","page":"Problem Definition","title":"FastIBPM.Primal","text":"struct Primal <: GridKind end\n\nA GridKind tag for the main grid, typically used for primary variables (e.g., velocity).\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Dual","page":"Problem Definition","title":"FastIBPM.Dual","text":"struct Dual <: GridKind end\n\nA GridKind tag for the offset (dual) grid, often used for derived quantities (e.g., vorticity, pressure).\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.GridLocation","page":"Problem Definition","title":"FastIBPM.GridLocation","text":"abstract type GridLocation{K<:GridKind} end\n\nAn abstract type representing where a variable is stored on a grid (e.g., node, cell, edge). It is parameterized by the GridKind K (either Primal or Dual).\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Node","page":"Problem Definition","title":"FastIBPM.Node","text":"struct Node{K} <: GridLocation{K} end\n\nA GridLocation type indicating that a variable lives at a node of a grid of kind K.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Edge","page":"Problem Definition","title":"FastIBPM.Edge","text":"struct Edge{K} <: GridLocation{K}\n    i::Int\nend\n\nA GridLocation type indicating that a variable lives on an edge of a grid of kind K.\n\nFields\n\ni::Int: Specifies the direction of the edge (e.g., 1 for x, 2 for y).\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Loc_u","page":"Problem Definition","title":"FastIBPM.Loc_u","text":"const Loc_u = Edge{Primal}\n\nType alias for velocity, stored on the edges of the Primal grid.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Loc_ω","page":"Problem Definition","title":"FastIBPM.Loc_ω","text":"const Loc_ω = Edge{Dual}\n\nType alias for vorticity, stored on the edges of the Dual grid.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.Grid","page":"Problem Definition","title":"FastIBPM.Grid","text":"struct Grid{N,T<:AbstractFloat}\n    h::T\n    n::SVector{N,Int}\n    x0::SVector{N,T}\n    levels::Int\nend\n\nDefines a multi-resolution, uniform Cartesian grid.\n\nFields\n\nh::T: Grid spacing (a scalar float, e.g., 0.01).\nn::SVector{N,Int}: Number of grid cells in each spatial dimension N.\nx0::SVector{N,T}: Position of the bottom-left (origin) corner of the grid.\nlevels::Int: Number of grid levels for multigrid.\n\nConstructor\n\nGrid(h::T, n, x0, levels)\n\nCreates a Grid. The number of cells n in each dimension is automatically rounded up to the nearest multiple of 4 to ensure compatibility with certain solvers (e.g., FFTs or multigrid coarsening).\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.gridcorner","page":"Problem Definition","title":"FastIBPM.gridcorner","text":"gridcorner(grid::Grid)\n\nReturns the corner position (origin) of the base grid (grid.x0).\n\nArguments\n\ngrid::Grid: The grid object.\n\nReturns\n\nSVector: The physical coordinates of the grid's corner.\n\n\n\n\n\ngridcorner(grid::Grid, level::Integer)\n\nComputes the corner position (origin) of a coarser multigrid level, which is centered relative to the fine grid.\n\nArguments\n\ngrid::Grid: The grid object.\nlevel::Integer: The multigrid level.\n\nReturns\n\nSVector: The physical coordinates of the coarse grid's corner.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.gridstep","page":"Problem Definition","title":"FastIBPM.gridstep","text":"gridstep(grid::Grid)\n\nReturns the grid spacing (e.g., Δx) for the base grid (grid.h).\n\nArguments\n\ngrid::Grid: The grid object.\n\nReturns\n\nT: The base grid spacing.\n\n\n\n\n\ngridstep(grid::Grid, level::Integer)\n\nComputes the grid spacing for a coarser multigrid level. Each level doubles the spacing (grid.h * 2^(level - 1)).\n\nArguments\n\ngrid::Grid: The grid object.\nlevel::Integer: The multigrid level.\n\nReturns\n\nT: The coarse grid spacing.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.coord","page":"Problem Definition","title":"FastIBPM.coord","text":"coord(grid::Grid, loc, I::SVector{N,<:Integer}, args...)\n\nComputes the physical coordinates for a given grid index I and GridLocation loc. This is the core logic that accounts for staggered grid offsets.\n\nArguments\n\ngrid::Grid: The grid object.\nloc::GridLocation: The location type (e.g., Node(), Edge{Primal}(1)).\nI::SVector: The integer grid index.\nargs...: Optional multigrid level.\n\nReturns\n\nSVector: The physical coordinates x(I) = x0 + h * (I + offset).\n\n\n\n\n\ncoord(grid, loc, I::Tuple, args...)\n\nConvenience method for coord that accepts indices as a Tuple.\n\n\n\n\n\ncoord(grid, loc, I::CartesianIndex, args...)\n\nConvenience method for coord that accepts indices as a CartesianIndex.\n\n\n\n\n\ncoord(grid, loc, r::Tuple{Vararg{AbstractRange}}, args...)\n\nComputes the physical coordinate ranges corresponding to a block of grid indices.\n\nArguments\n\ngrid: The grid object.\nloc: The grid location.\nr::Tuple{Vararg{AbstractRange}}: A tuple of index ranges.\nargs...: Optional multigrid level.\n\nReturns\n\nTuple: A tuple of physical coordinate ranges (e.g., (xrange, yrange)).\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM._cellcoord","page":"Problem Definition","title":"FastIBPM._cellcoord","text":"_cellcoord(loc::Edge{Primal}, ::Val{N})\n\nComputes the fractional cell offset for a Primal edge (e.g., velocity). This is a half-cell offset in directions other than the edge's direction i.\n\nArguments\n\nloc::Edge{Primal}: The primal edge location.\n::Val{N}: The grid dimension.\n\nReturns\n\nSVector: A vector of fractional offsets (e.g., [0.0, 0.5]).\n\n\n\n\n\n_cellcoord(loc::Edge{Dual}, ::Val{N})\n\nComputes the fractional cell offset for a Dual edge (e.g., vorticity). This is a half-cell offset along the edge's direction i.\n\nArguments\n\nloc::Edge{Dual}: The dual edge location.\n::Val{N}: The grid dimension.\n\nReturns\n\nSVector: A vector of fractional offsets (e.g., [0.5, 0.0]).\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.IncludeBoundary","page":"Problem Definition","title":"FastIBPM.IncludeBoundary","text":"struct IncludeBoundary end\n\nTag type used as a flag to request index ranges that include boundary points.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.ExcludeBoundary","page":"Problem Definition","title":"FastIBPM.ExcludeBoundary","text":"struct ExcludeBoundary end\n\nTag type used as a flag to request index ranges that exclude boundary points, returning only the grid interior.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.cell_axes","page":"Problem Definition","title":"FastIBPM.cell_axes","text":"cell_axes(n::SVector{N}, loc::Edge, ::IncludeBoundary)\n\nDetermines the iterable index ranges for a grid location, including boundaries.\n\nArguments\n\nn::SVector{N}: Number of grid cells per dimension.\nloc::Edge: The grid location.\n::IncludeBoundary: Tag specifying boundary inclusion.\n\nReturns\n\nTuple of UnitRange: Index ranges (e.g., (0:n[1], 0:n[2]-1)).\n\n\n\n\n\ncell_axes(n::SVector{N}, loc::Edge, ::ExcludeBoundary)\n\nDetermines the iterable index ranges for a grid location, excluding boundaries.\n\nArguments\n\nn::SVector{N}: Number of grid cells per dimension.\nloc::Edge: The grid location.\n::ExcludeBoundary: Tag specifying boundary exclusion.\n\nReturns\n\nTuple of UnitRange: Index ranges for the interior (e.g., (1:n[1]-1, 0:n[2]-1)).\n\n\n\n\n\ncell_axes(n::SVector{N}, loc::Type{<:Edge}, args...)\n\nVectorized method for cell_axes. Returns a map of axes for all possible edge directions of a given Edge type.\n\nArguments\n\nn::SVector{N}: Number of grid cells per dimension.\nloc::Type{<:Edge}: The edge type (e.g., Loc_u).\nargs...: Boundary flags (IncludeBoundary or ExcludeBoundary).\n\nReturns\n\nA map or OffsetTuple containing the axes for each component.\n\n\n\n\n\ncell_axes(grid::Grid, args...)\n\nConvenience method for cell_axes that extracts the cell count n from the Grid object.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.grid_length","page":"Problem Definition","title":"FastIBPM.grid_length","text":"grid_length(grid::Grid, loc::Edge, args...)\n\nComputes the total number of grid points for a single edge-centered component.\n\nArguments\n\ngrid::Grid: The grid object.\nloc::Edge: The specific edge component (e.g., Loc_u(1)).\nargs...: Boundary flags (IncludeBoundary or ExcludeBoundary).\n\nReturns\n\nInt: The total number of points (prod(length, cell_axes(...)).\n\n\n\n\n\ngrid_length(grid::Grid{N}, loc::Type{<:Edge}, args...)\n\nComputes the total number of grid points summed over all components of a given Edge type.\n\nArguments\n\ngrid::Grid: The grid object.\nloc::Type{<:Edge}: The edge type (e.g., Loc_u).\nargs...: Boundary flags.\n\nReturns\n\nInt: The sum of points over all components.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM._on_bndry","page":"Problem Definition","title":"FastIBPM._on_bndry","text":"_on_bndry(loc::Edge{Primal}, j)\n\nUtility function. Returns true if a Primal edge (like velocity) is defined on the boundary in direction j.\n\nArguments\n\nloc::Edge{Primal}: The primal edge location.\nj::Int: The coordinate direction to check.\n\nReturns\n\nBool: true if loc.i == j, false otherwise.\n\n\n\n\n\n_on_bndry(loc::Edge{Dual}, j)\n\nUtility function. Returns true if a Dual edge (like vorticity) is defined on the boundary in direction j.\n\nArguments\n\nloc::Edge{Dual}: The dual edge location.\nj::Int: The coordinate direction to check.\n\nReturns\n\nBool: true if loc.i != j, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.boundary_axes","page":"Problem Definition","title":"FastIBPM.boundary_axes","text":"boundary_axes(n::SVector{N}, loc::Edge)\n\nReturns ranges of grid indices that lie exactly on the boundaries of a single edge-defined field component.\n\nArguments\n\nn::SVector{N}: Number of grid cells per dimension.\nloc::Edge: A specific edge component (e.g., Loc_u(1)).\n\nReturns\n\nSArray: An array of index ranges for each boundary face (e.g., left, right, top, bottom).\n\n\n\n\n\nboundary_axes(n::SVector{N}, loc::Type{<:Edge}; dims=...)\n\nApplies boundary_axes to all edge directions for a vector-valued field, returning a list of boundary index ranges for each component.\n\nArguments\n\nn::SVector{N}: Number of grid cells per dimension.\nloc::Type{<:Edge}: An edge type (e.g., Loc_u).\ndims: The dimensions to iterate over.\n\nReturns\n\nA map of results from the single-component boundary_axes method.\n\n\n\n\n\nboundary_axes(grid::Grid, args...; kw...)\n\nConvenience method for boundary_axes that extracts the cell count n from the Grid object.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.boundary_length","page":"Problem Definition","title":"FastIBPM.boundary_length","text":"boundary_length(grid::Grid, loc::Edge)\n\nComputes the total number of degrees of freedom (grid points) located exactly on the boundaries for a single staggered field component.\n\nArguments\n\ngrid::Grid: The grid object.\nloc::Edge: A specific edge component.\n\nReturns\n\nInt: Total number of boundary points for this component.\n\n\n\n\n\nboundary_length(grid::Grid{N}, loc::Type{<:Edge})\n\nComputes the total number of boundary degrees of freedom summed over all components of a given Edge type.\n\nArguments\n\ngrid::Grid: The grid object.\nloc::Type{<:Edge}: An edge type (e.g., Loc_u).\n\nReturns\n\nInt: Sum of boundary points over all components.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM._exclude_boundary","page":"Problem Definition","title":"FastIBPM._exclude_boundary","text":"_exclude_boundary(a, grid, loc)\n\nReturns a collection of \"interior\" views of an array a, excluding boundary points.\n\nArguments\n\na: An array or tuple of arrays (one for each field component).\ngrid::Grid: The grid object.\nloc: The grid location type (e.g., Loc_u).\n\nReturns\n\nA Tuple or Array of non-allocating views (@view) into the interior region of each component array in a.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.edge_axes","page":"Problem Definition","title":"FastIBPM.edge_axes","text":"edge_axes(::Val{N}, loc::Type{<:Edge})\n\nProvides the list of possible directions (axes) associated with edges on a grid of dimension N.\n\nArguments\n\n::Val{N}: The grid dimension.\nloc::Type{<:Edge}: The edge type.\n\nReturns\n\nA tuple of directions, e.g., (1, 2) for N=2.\n\n\n\n\n\nedge_axes(::Val{2}, loc::Type{Edge{Dual}})\n\nProvides the list of axes for a 2D Dual edge. This is a special case, likely for 2D vorticity, which returns OffsetTuple{3}((3,)) to represent the single z-component.\n\nArguments\n\n::Val{2}: The grid dimension (specifically 2).\nloc::Type{Edge{Dual}}: The Dual edge type.\n\nReturns\n\nOffsetTuple{3}((3,))\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.grid_zeros","page":"Problem Definition","title":"FastIBPM.grid_zeros","text":"grid_zeros(backend, grid, loc::GridLocation, bndry=IncludeBoundary())\n\nCreates a single array of zeros, correctly sized and indexed for a given grid location, allocated on the specified backend.\n\nArguments\n\nbackend: The KernelAbstractions backend (e.g., CPU()).\ngrid::Grid: The grid object.\nloc::GridLocation: The specific grid location (e.g., Loc_u(1)).\nbndry: Boundary flag (default: IncludeBoundary()).\n\nReturns\n\nA single OffsetArray of zeros, with indices matching cell_axes.\n\n\n\n\n\ngrid_zeros(backend, grid, loc::Type{<:Edge}, args...; levels=1)\n\nCreates a structure of zero-filled arrays for all components of an Edge type, potentially replicated for multiple multigrid levels.\n\nArguments\n\nbackend: The KernelAbstractions backend.\ngrid::Grid: The grid object.\nloc::Type{<:Edge}: The edge type (e.g., Loc_u).\nargs...: Boundary flags.\nlevels::Int: Number of multigrid levels (default: 1).\n\nReturns\n\nA map (or OffsetTuple) of arrays for all components, potentially nested inside another map if levels > 1.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.boundary_zeros","page":"Problem Definition","title":"FastIBPM.boundary_zeros","text":"boundary_zeros(backend, grid::Grid{N,T}, loc)\n\nReturns a nested structure of zero-filled arrays to store values on the grid boundaries. These arrays are correctly indexed OffsetArrays allocated on the specified backend.\n\nArguments\n\nbackend: The KernelAbstractions backend.\ngrid::Grid: The grid object.\nloc: The grid location type (e.g., Loc_u).\n\nReturns\n\nA nested structure: map over components -> SArray over faces -> OffsetArray of zeros for that specific boundary face.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.grid_view","page":"Problem Definition","title":"FastIBPM.grid_view","text":"grid_view(a, grid, loc, bndry)\n\nCreates views of grid data arrays, sliced according to the active region defined by cell_axes.\n\nArguments\n\na: An array or tuple of arrays (one for each field component).\ngrid::Grid: The grid object.\nloc: The grid location type (e.g., Loc_u).\nbndry: Boundary flag (IncludeBoundary() or ExcludeBoundary()).\n\nReturns\n\nA map of non-allocating views (@view) into the active region of each component array in a.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.IrrotationalFlow","page":"Problem Definition","title":"FastIBPM.IrrotationalFlow","text":"IrrotationalFlow\n\nAbstract type specifying a flow where the curl of the velocity is zero (∇ × u = 0). This is a \"tag\" type used for dispatch.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.UniformFlow","page":"Problem Definition","title":"FastIBPM.UniformFlow","text":"UniformFlow(u)\n\nA type of IrrotationalFlow representing a flow that is uniform in space but may vary in time.\n\nFields\n\nu: The freestream velocity. Can be a constant SVector or a function u(t) that returns an SVector.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.add_flow!","page":"Problem Definition","title":"FastIBPM.add_flow!","text":"add_flow!(u, flow::UniformFlow, _, _, _, t)\n\nAdds the background UniformFlow velocity to the velocity field u in-place. Computes u_new = u_old + u_flow(t).\n\nArguments\n\nu: The velocity field (e.g., a tuple of arrays). Modified in-place.\nflow::UniformFlow: The background flow object.\n_: Placeholders for unused arguments.\nt: The current simulation time.\n\nReturns\n\nThe modified velocity field u.\n\n\n\n\n\n","category":"function"},{"location":"problem_definition/#FastIBPM.BodyPoints","page":"Problem Definition","title":"FastIBPM.BodyPoints","text":"struct BodyPoints{N,T,V<:AbstractVector{SVector{N,T}},S<:AbstractVector{T}}\n    x::V\n    u::V\n    ds::S\nend\n\nAn \"immersed object container\" that holds the Lagrangian body points and their attributes.\n\nFields\n\nx: Vector of body point positions (each an SVector{N,T}).\nu: Vector of body point velocities (each an SVector{N,T}).\nds: Vector of quadrature weights (e.g., line segment lengths) for each point.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#Base.view-Tuple{FastIBPM.BodyPoints, Any}","page":"Problem Definition","title":"Base.view","text":"Base.view(points::BodyPoints, r)\n\nOverloads Base.view to create a lightweight, non-allocating \"slice\" or \"window\" of a BodyPoints object.\n\nArguments\n\npoints::BodyPoints: The original BodyPoints object.\nr: An index range (e.g., 201:400).\n\nReturns\n\nBodyPoints: A new BodyPoints object whose fields (x, u, ds) are views into the fields of the original object.\n\n\n\n\n\n","category":"method"},{"location":"problem_definition/#FastIBPM.AbstractBody","page":"Problem Definition","title":"FastIBPM.AbstractBody","text":"AbstractBody\n\nAn abstract type defining the interface for a body that interacts with the fluid. A body specifies a set of points and prescribes the flow velocity in a small region near each point.\n\n\n\n\n\n","category":"type"},{"location":"problem_definition/#FastIBPM.IBProblem","page":"Problem Definition","title":"FastIBPM.IBProblem","text":"struct IBProblem{N,T,B<:AbstractBody,U<:IrrotationalFlow}\n    grid::Grid{N,T}\n    body::B\n    Re::T\n    u0::U\nend\n\nDefines the entire immersed boundary problem to be solved. An IBProblem instance contains all necessary components: grid, body, Reynolds number, and background flow.\n\nParameters\n\nN: Dimension of the problem (2D or 3D).\nT: Scalar type (e.g., Float64).\nB<:AbstractBody: The concrete body type.\nU<:IrrotationalFlow: The concrete background flow type.\n\nFields\n\ngrid::Grid{N,T}: The fluid grid.\nbody::B: The immersed body (must be a subtype of AbstractBody).\nRe::T: The Reynolds number.\nu0::U: The background flow (must be a subtype of IrrotationalFlow).\n\n\n\n\n\n","category":"type"},{"location":"prescribed_bodies/#FastIBPM.NothingBody","page":"Prescribed Bodies","title":"FastIBPM.NothingBody","text":"NothingBody{}\n\nThe NothingBody struct defines a trivial, empty static body used as a placeholder when no physical body is present.\n\nRelated functions\n\nFunctions associated with NothingBody perform no operations:\n\npoint_count(::NothingBody): returns 0 (no points).\ninit_body_points!(::BodyPoints, ::NothingBody): does nothing.\nupdate_body_points!(::BodyPoints, ::NothingBody, i, t): does nothing.\n\n\n\n\n\n","category":"type"},{"location":"prescribed_bodies/#FastIBPM.StaticBody","page":"Prescribed Bodies","title":"FastIBPM.StaticBody","text":"StaticBody{N,T,S<:AbstractVector{T},A<:AbstractVector{SVector{N,T}}}\n\nThe StaticBody struct represents a real, immobile body.\n\nFields\n\nx::A : Vector of positions (SVector{N,T}) in N-dimensional space.\nds::S : Vector of weights or spacings associated with points.\n\nType parameters\n\nN : Spatial dimension.\nT : Scalar type (e.g., Float64).\nS : Type of vector for ds.\nA : Type of vector for x.\n\nRelated functions\n\npoint_count(body) : Returns the number of points on the body.\ninit_body_points!(points, body) : Initializes BodyPoints with the static body's positions, zero velocities, and spacings.\nupdate_body_points!(points, body, i, t) : No-op; static bodies do not move.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#CNAB","page":"CNAB","title":"CNAB","text":"","category":"section"},{"location":"cnab/#FastIBPM.AbstractCoupler","page":"CNAB","title":"FastIBPM.AbstractCoupler","text":"AbstractCoupler\n\nAbstract interface for coupling strategies in the CNAB time integration framework.\n\nThis type defines a common interface for different coupler implementations that manage interactions between PDE components or immersed bodies during time integration. Specific couplers include:\n\nNothingCoupler          : No coupling required.\nPrescribedBodyCoupler   : For bodies with prescribed motion or known behavior.\nFsiCoupler              : For fluid-structure interaction problems.\n\nArguments\n\nNone.\n\nReturns\n\nAn abstract type that serves as a base for all coupling strategies used in CNAB-based simulations.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.NothingCoupler","page":"CNAB","title":"FastIBPM.NothingCoupler","text":"NothingCoupler\n\nA simple subtype of AbstractCoupler representing the absence of coupling.\n\nUse this type when no body-fluid interaction or other coupling is required in the CNAB time integration framework. It serves as a placeholder that satisfies the coupler interface without modifying the solution.\n\nArguments\n\nNone.\n\nReturns\n\nAn instance of NothingCoupler, indicating that no coupling is applied during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.PrescribedBodyCoupler","page":"CNAB","title":"FastIBPM.PrescribedBodyCoupler","text":"PrescribedBodyCoupler{M}\n\nA subtype of AbstractCoupler for prescribed body motion or constraints.\n\nThis coupler stores a field Binv, representing a precomputed operator used to enforce prescribed motion (and forces) on the body. The type M is parametric, allowing flexibility in the data structure used for Binv (e.g., arrays or linear operators).\n\nArguments\n\nBinv::M : Precomputed operator or matrix used to apply constraints for the prescribed body.\n\nReturns\n\nAn instance of PrescribedBodyCoupler suitable for simulations where body motion or behavior is explicitly prescribed.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.FsiCoupler","page":"CNAB","title":"FastIBPM.FsiCoupler","text":"FsiCoupler{T,O<:GeometricNonlinearBodyOperators,B}\n\nA subtype of AbstractCoupler for fluid–structure interaction (FSI) problems  with nonlinear structural dynamics.\n\nThis type encapsulates the structural state, geometric nonlinear operators, solver  tolerance, BiCGStab solver arguments, and iteration limits required for solving  coupled FSI problems using the CNAB time integration framework. \n\nThe keyword constructor allows easy setup of the coupler, including automatic  initialization of the structural state and operators for a given GeometricNonlinearBody.\n\nFields\n\nstate::StructuralState{T}          : Current state of the structural body (displacements, velocities, deformations), parameterized by numeric type T.\nops::O                             : Operator object representing the geometric nonlinear structural model.\ntol::T                             : Numerical tolerance for the iterative solve.\nbicgstabl_args::B                  : Arguments for the BiCGStab(ℓ) iterative solver (tuple or named container).\nmaxiter::Int                       : Maximum iterations during the solver phase.\n\nArguments (via keyword constructor)\n\nbackend::CPU                       : Computation backend (CPU-based).\nbody::GeometricNonlinearBody{N,T}  : Nonlinear structural body with N spatial dimensions and numeric type T.\ntol                                : Solver tolerance (default 1e-5).\nbicgstabl_args                     : Solver arguments (default (; abstol=T(1e-5), reltol=T(0.0))).\nmaxiter::Int                       : Maximum iterations (default 100).\n\nReturns\n\nA fully initialized FsiCoupler instance ready to couple the fluid and structural solvers in FSI simulations.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.CNAB","page":"CNAB","title":"FastIBPM.CNAB","text":"CNAB{N,T,B,U,P,R<:Reg,C<:AbstractCoupler,Au,Aω,Vb,BP<:BodyPoints,A<:ArrayPool,W}\n\nCentral mutable type representing the state and configuration of a Crank–Nicolson  Adams–Bashforth (CNAB) time integration scheme for coupled fluid–structure simulations.\n\nThis struct holds all data required for time-stepping the simulation, including  fluid and body fields, transform plans, regularization operators, memory pools,  and solver buffers. It is designed for high-performance computing with support  for GPU/CPU backends and flexible handling of complex bodies and couplers.\n\nFields\n\nprob::IBProblem{N,T,B,U}             : The immersed boundary problem defining the grid and bodies.\nt0::T                                : Initial simulation time.\ni::Int                               : Current time step index.\nt::T                                 : Current simulation time.\ndt::T                                : Time step size.\nβ::Vector{T}                         : CNAB scheme coefficients.\nplan::P                              : FFT or spectral transform plan.\nreg::R                               : Regularizer or interpolation operator.\ncoupler::C                           : Coupling strategy (FsiCoupler, PrescribedBodyCoupler, NothingCoupler).\nredist_weights::Au                   : Redistribution weights for fluid variables.\nω::Vector{Aω}                        : Vorticity field(s).\nψ::Vector{Aω}                        : Streamfunction or auxiliary field(s).\nu::Vector{Au}                        : Velocity field(s).\nf_tilde::Vb, f::Vb                 : Body force arrays.\npoints::BP                           : Body point data structure.\nnonlin::Vector{Vector{Aω}}           : Buffers for nonlinear term history.\nnonlin_count::Int                    : Counter for nonlinear buffers.\nω_bndry::W                           : Boundary vorticity data.\nbody_pool::A, fluid_pool::A, bndry_pool::A, structure_pool::A : Memory pools to reduce allocations.\n\nArguments (via constructor)\n\nprob::IBProblem{N,T}                 : Immersed boundary problem containing grid and body setup.\ndt                                   : Time step size.\nt0                                   : Initial simulation time (default 0).\nn_step                               : Number of previous time steps to retain for CNAB (default 2).\ndelta                                : Regularization kernel (default DeltaYang3S()).\nbackend                              : Computation backend (CPU() or GPU device).\ncoupler_args                         : Keyword arguments for the coupling constructor (e.g., FsiCoupler).\n\nDescription\n\nThe constructor automatically allocates all buffers, precomputes FFT plans,  regularization operators, and memory pools, and bundles them into a CNAB object  ready for time integration. It performs the following main steps:\n\nSetup grid and body: retrieves grid and body from prob.  \nPre-allocate main fluid field: creates vorticity arrays.  \nCreate FFT plan: precomputes spectral transforms for efficient solves.  \nDetermine problem sizes: computes number of body points and structure variables.  \nAllocate memory pools: sizes pools for fluid, body, boundary, and structure arrays.  \nBundle arguments: stores all fields and buffers in a named tuple.  \nBuild the solution object: calls initial_sol to wrap arguments into a fully initialized CNAB instance.\n\nReturns\n\nA CNAB object fully initialized for coupled time-stepping with the CNAB scheme.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.CNAB_Binv_Precomputed","page":"CNAB","title":"FastIBPM.CNAB_Binv_Precomputed","text":"CNABBinvPrecomputed(B)\n\nA precomputed coupling operator for the CNAB solver.\n\nHolds a precomputed matrix B used to solve the body–fluid coupling system  directly. Efficient when B is constant (e.g., for rigid or prescribed-motion bodies).\n\nThe object is callable like a function to compute the body force f given the  desired body velocity u_ib and the CNAB solver sol.\n\nArguments:\n\nB: Precomputed coupling matrix.\nf: Body force vector (updated in-place).\nu_ib: Coupling right-hand side (desired body velocity minus interpolated fluid velocity).\nsol::CNAB: CNAB solver object (included for signature consistency, not used here).\n\nReturns:\n\nUpdates f in-place.\n\n\n\n\n\n","category":"type"},{"location":"cnab/#FastIBPM.initial_sol","page":"CNAB","title":"FastIBPM.initial_sol","text":"initial_sol(backend, body, sol_args, coupler_args)\n\nInitialize a CNAB simulation object based on the type of body in the problem.\n\nThis function has two methods depending on whether body is a static or geometrically  nonlinear (deforming) body:\n\nStatic Body Initialization (AbstractStaticBody)  \nConstructs a temporary CNAB with a NothingCoupler.  \nInitializes body point positions.  \nComputes regularization weights.  \nComputes the inverse of the body–fluid coupling matrix.  \nCreates a PrescribedBodyCoupler with the precomputed operator.  \nBuilds the final CNAB object with the coupler.  \nSets simulation time and initializes fluid fields.\nGeometric Nonlinear Body Initialization (GeometricNonlinearBody)  \nConstructs an FsiCoupler for nonlinear structural dynamics.  \nBuilds the CNAB object with this coupler.  \nSets simulation time and zeros the fluid fields.  \nSplits prescribed and deforming points.  \nInitializes prescribed body points.  \nUpdates the structural state and initializes structure operators.  \nComputes regularization and redistribution weights.\n\nArguments\n\nbackend                 : Computation backend (CPU() or GPU device).  \nbody                    : The body in the problem (AbstractStaticBody or GeometricNonlinearBody).  \nsol_args                : Named tuple with CNAB fields and buffers.  \ncoupler_args            : Keyword arguments passed to the coupler constructor.\n\nReturns\n\nA fully initialized CNAB object ready for time integration, configured according  to the type of body and the specified coupling strategy.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.zero_vorticity!","page":"CNAB","title":"FastIBPM.zero_vorticity!","text":"zero_vorticity!(sol::CNAB)\n\nReset all fluid-related fields in a CNAB simulation object.\n\nThis function sets the vorticity (ω), streamfunction (ψ), and velocity (u)  fields to zero across all grid levels. It also resets the nonlinear history counter  and re-applies the initial prescribed flow field (u0).\n\nArguments\n\nsol::CNAB : The CNAB simulation object whose fluid fields are being reset.\n\nReturns\n\nThe updated CNAB object with zeroed fluid fields and initial flow re-applied.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.set_time!","page":"CNAB","title":"FastIBPM.set_time!","text":"set_time!(sol::CNAB, i::Integer)\n\nAdvance the CNAB integrator to a specific time step.\n\nThis function updates the internal step index (i) and computes the corresponding  physical time (t) of the simulation using:\n\nt = t0 + dt * (i - 1)\n\nwhere t0 is the initial simulation time and dt is the time step size. This ensures  that all time-dependent operations in the simulation remain consistent.\n\nArguments\n\nsol::CNAB : The CNAB simulation object to update.\ni::Integer : The target time step index.\n\nReturns\n\nThe updated CNAB object with the new time step and physical time.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.step!","page":"CNAB","title":"FastIBPM.step!","text":"step!(sol::CNAB)\n\nAdvance the CNAB simulation by one time step.\n\nThis is the main time integration routine that updates both the fluid and structure  fields according to the CNAB scheme. A single call to step! performs the following sequence:\n\nAdvance the simulation time step (set_time!).  \nPredict the new fluid and body state (prediction_step!).  \nApply fluid–structure coupling (coupling_step!).  \nProject the velocity field to enforce incompressibility (projection_step!).  \nUpdate the vorticity field (apply_vorticity!).  \n\nArguments\n\nsol::CNAB : The CNAB simulation object representing the current state.\n\nReturns\n\nThe updated CNAB object after one complete time step.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.update_reg!","page":"CNAB","title":"FastIBPM.update_reg!","text":"update_reg!(sol::CNAB, body, i)\n\nUpdate the regularization weights for the simulation based on the type of body.\n\nThere are two methods:\n\nStatic bodies (AbstractStaticBody)  \nNo update is necessary because the body does not move or deform.  \nThe function returns nothing.\nPrescribed-motion bodies (AbstractPrescribedBody)  \nUpdates the regularization weights by calling update_weights! with the  current body point positions.  \nEnsures that the mapping from body points to the grid reflects the current motion.\n\nArguments\n\nsol::CNAB : CNAB simulation object containing the grid and body fields.  \nbody      : The body object (AbstractStaticBody or AbstractPrescribedBody).  \ni         : Index or set of points for which the regularization is updated (used for prescribed bodies).\n\nReturns\n\nNothing for static bodies.  \nUpdates sol.reg in-place for prescribed-motion bodies.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM._A_factor","page":"CNAB","title":"FastIBPM._A_factor","text":"_A_factor(sol::CNAB)\n\nCompute the diffusion coefficient used in the CNAB time-stepping scheme.\n\nThis coefficient arises in the semi-implicit (Crank–Nicolson) treatment of the viscous term and is given by:\n\nA = Δt / (2 * Re)\n\nArguments\n\nsol::CNAB : CNAB simulation object containing the current state and parameters.\n\nReturns\n\nDiffusion coefficient (same numeric type as sol.dt).\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.Ainv","page":"CNAB","title":"FastIBPM.Ainv","text":"Ainv(sol::CNAB, level)\n\nConstruct the inverse viscous operator used in the CNAB time-stepping scheme.\n\nArguments\n\nsol::CNAB: CNAB simulation object containing the problem definition and FFT plans.\nlevel: Grid refinement level at which to build the operator.\n\nReturns\n\nEigenbasisTransform: An operator that applies the inverse of (I - aΔ) in spectral space, typically used for implicit diffusion updates within the CNAB integrator.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.prediction_step!","page":"CNAB","title":"FastIBPM.prediction_step!","text":"prediction_step!(sol::CNAB)\nprediction_step!(sol::CNAB, level)\nprediction_step!(sol::CNAB, level, u_work)\n\nPerform the CNAB prediction of the vorticity field.\n\nThis function advances the fluid state by computing the predicted vorticity using a semi-implicit Crank–Nicolson treatment for diffusion and an Adams–Bashforth treatment for nonlinear convection. It supports multigrid levels and avoids unnecessary allocations with array pools.\n\nArguments\n\nsol::CNAB: CNAB simulation object.\nlevel (optional): Grid level for single-level update.\nu_work (optional): Preallocated velocity array for in-place computation.\n\nReturns\n\nUpdated vorticity field in-place within sol.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.coupling_step!","page":"CNAB","title":"FastIBPM.coupling_step!","text":"coupling_step!(sol::CNAB)\n\nPerform the fluid–structure coupling step for the current CNAB time step.\n\nThis function dispatches to the appropriate coupling routine based on the solver's coupler. For a prescribed body, it computes the fluid velocity at body points, evaluates the coupling residual, and solves for the correcting body force to enforce velocity constraints.\n\nArguments\n\nsol::CNAB: CNAB simulation object with the current fluid and body state.\n\nReturns\n\nUpdates sol.f_tilde and body-related fields in-place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM._coupling_step!","page":"CNAB","title":"FastIBPM._coupling_step!","text":"_coupling_step!(sol::CNAB, coupler::FsiCoupler)\n_coupling_step!(sol::CNAB, coupler::FsiCoupler, fs, χs, ψ_b_work)\n\nAdvance the fluid–structure interaction (FSI) system for deformable bodies.\n\nThis function couples the fluid and structure dynamics within the immersed boundary framework, ensuring that the motion of a deformable body and the surrounding fluid remain consistent.\n\nThe first method prepares temporary arrays and calls the main solver. The second performs the actual coupling iterations until convergence.\n\nPurpose\n\nUsed in simulations where the body can deform under fluid forces. It enforces the mutual interaction between fluid and structure during each time step.\n\nNotes\n\nWorks with deformable immersed bodies through an implicit iterative scheme.\n\nReturns\n\nNothing. Updates the solver state in place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.B_inverse_rigid","page":"CNAB","title":"FastIBPM.B_inverse_rigid","text":"B_inverse_rigid(sol::CNAB{N,T,<:AbstractStaticBody})\n\nConstruct a precomputed coupling operator for a rigid (static) body.\n\nThis function builds the body–fluid coupling matrix B and precomputes its inverse via Cholesky factorization. The returned object is a  CNAB_Binv_Precomputed, which can be applied during the CNAB  coupling step as coupler.Binv(sol.f_tilde, rhs, sol).\n\nOnly for static/non-deforming bodies.\nPrecomputing B ensures fast solves at each timestep.\nThe matrix is assumed symmetric positive definite (SPD).\n\nInputs\n\nsol::CNAB: CNAB simulation object containing the body and grid.\n\nReturns\n\nCNAB_Binv_Precomputed: Callable object that efficiently applies B⁻¹.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.B_rigid_mul!","page":"CNAB","title":"FastIBPM.B_rigid_mul!","text":"B_rigid_mul!(u_ib, f, sol::CNAB{N,T})\n\nApply the rigid-body coupling operator to a force vector.\n\nThis function defines the action of the rigid-body coupling matrix B such that u_ib = B * f, where f is a body force distribution and u_ib is the resulting velocity at the immersed boundary points.\n\nTwo methods are provided:\n\nA wrapper that reinterprets flat arrays as vectors of SVector{N,T} and calls the core implementation.\nThe main routine, which:\nRegularizes the body forces to the fluid grid.\nSolves for the induced velocity field via the vorticity–streamfunction formulation.\nInterpolates the resulting fluid velocity back to the body points.\n\nThis operation is used when assembling the coupling matrix in B_inverse_rigid and represents how the fluid mediates the response of the rigid body to applied forces.\n\nInputs\n\nu_ib: Output array for body velocities.\nf: Body force vector.\nsol::CNAB: CNAB solver containing grid, operators, and regularization data.\n\nReturns\n\nu_ib: The updated body velocity vector after applying the operator.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.B_deform_mul!","page":"CNAB","title":"FastIBPM.B_deform_mul!","text":"B_deform_mul!(u_ib, f, sol::CNAB)\n\nApply the fluid–structure coupling operator B for a deformable body.\n\nThis function maps body forces f to immersed-boundary velocities u_ib, accounting for force spreading, structural response, and velocity interpolation back to the Lagrangian points.\n\nThree methods are provided:\n\nA converter that reinterprets flat scalar vectors as structured SVector arrays.\nA wrapper that allocates workspace arrays.\nThe core routine that computes the coupled fluid–structure response.\n\nArguments\n\nu_ib : Output array for body velocities (updated in-place).\nf    : Input body force vector.\nsol::CNAB : CNAB solver object containing grid, operators, and regularization.\n\nReturns\n\nu_ib updated in-place with the velocity induced by f.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.f_to_f_tilde!","page":"CNAB","title":"FastIBPM.f_to_f_tilde!","text":"f_to_f_tilde!(f, sol::CNAB; inverse=false)\n\nConvert between the physical body force f and its regularized (spread) form f_tilde used in the fluid solver.\n\nThis function rescales the immersed boundary force depending on the direction of conversion:\n\nWhen inverse=false (default), it converts f_tilde → f, applying the proper scaling for the boundary point spacing and coupling factor.\nWhen inverse=true, it converts f → f_tilde, restoring the fluid solver’s representation of the force.\n\nThis transformation ensures consistent units and coupling strength between the structure and the fluid solvers.\n\nNotes\n\nThe conversion uses:\n\ndt : Time step size.\nds : Arc length of immersed boundary points.\nh  : Grid spacing.\nk = _f_tilde_factor(sol) : Coupling-dependent scaling factor.\n\nArguments\n\nf : Force vector, modified in-place.\nsol::CNAB : CNAB solver object containing time step, grid, and coupling parameters.\ninverse : Whether to apply the inverse scaling (f → f_tilde).\n\nReturns\n\nThis function returns nothing; the input f is modified in place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.redist!","page":"CNAB","title":"FastIBPM.redist!","text":"redist!(f, sol::CNAB)\n\nRedistribute forces on the immersed boundary to ensure consistency with the fluid.\n\nThis function corrects the body forces f after numerical operations by:\n\nSpreading the force to the fluid grid.\nApplying precomputed redistribution weights.\nInterpolating the corrected forces back to the body points.\n\nArguments\n\nf: The body force vector (modified in-place).\nsol::CNAB: The CNAB solver state containing fluid and body information.\n\nReturns\n\nnothing: The input f is updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.update_redist_weights!","page":"CNAB","title":"FastIBPM.update_redist_weights!","text":"update_redist_weights!(sol::CNAB; tol=1e-10)\n\nCompute the redistribution weights used in redist! to ensure consistent transfer of forces between the immersed boundary and the fluid grid.\n\nThe weights correct for imbalances caused by spreading forces from body points to the grid, so that later redistribution preserves the physical accuracy of the simulation.\n\nArguments\n\nsol::CNAB: The CNAB solver object containing the body and fluid state.\ntol: Minimum threshold for weight inversion to avoid division by zero (default 1e-10).\n\nReturns\n\nnothing: The redistribution weights are stored in sol.redist_weights and updated in-place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.projection_step!","page":"CNAB","title":"FastIBPM.projection_step!","text":"projection_step!(sol::CNAB)\n\nProject the fluid vorticity field to remove the effect of the applied body forces (f_tilde), ensuring that the flow field satisfies the updated constraints after force spreading and redistribution.\n\nArguments\n\nsol::CNAB: The CNAB solver object containing the fluid and body state.\n\nEffects\n\nModifies sol.ω in-place to account for the applied body forces.\nSwaps sol.ω and sol.ψ internally to reuse memory.\n\nReturns\n\nnothing: The projection modifies the solver state in-place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.apply_vorticity!","page":"CNAB","title":"FastIBPM.apply_vorticity!","text":"apply_vorticity!(sol::CNAB)\n\nCompute the fluid velocity field from the current vorticity (ω) and update the solution  to satisfy boundary conditions and base flow.\n\nArguments\n\nsol::CNAB: The CNAB solver object containing the fluid and body state.\n\nEffects\n\nUpdates sol.u (velocity field) and ensures sol.ω satisfies boundary conditions.\nHandles all multigrid levels, applying necessary interpolations between levels.\n\nReturns\n\nnothing: Modifies the solver state in-place.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.ab_coeffs","page":"CNAB","title":"FastIBPM.ab_coeffs","text":"ab_coeffs(T, n)\n\nReturn the Adams-Bashforth coefficients for a given order n.\n\nArguments\n\nT: Container type to hold the coefficients (e.g., Tuple or Vector).\nn: Order of the Adams-Bashforth scheme (currently only 1 or 2).\n\nReturns\n\nA container of type T with the AB coefficients:\nn = 1: [1] (forward Euler, AB1)\nn = 2: [-1//2, 3//2] (AB2)\n\nNotes\n\nAB1 is first-order explicit Euler.\nAB2 is second-order, using current and previous derivative values for better accuracy.\nOnly n=1 and n=2 are supported; other values throw a DomainError.\n\nExample\n\nab_coeffs(Tuple, 1)  # returns (1,)\nab_coeffs(Tuple, 2)  # returns (-1//2, 3//2)\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM._f_tilde_factor","page":"CNAB","title":"FastIBPM._f_tilde_factor","text":"_f_tilde_factor(sol)\n\nCompute the scaling factor used to convert between the physical body force f  and the regularized force f_tilde used in the fluid solver.\n\nArguments\n\nsol: CNAB solver object containing grid and time step information.\n\nReturns\n\nA scalar factor k = - h^N / Δt where:\nh is the uniform grid spacing\nN is the spatial dimension\nΔt is the time step size\nThe negative sign follows the solver convention for force transformation\n\nNotes\n\nThis factor is used in f_to_f_tilde! to scale forces correctly between  the immersed boundary and the fluid grid.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.surface_force!","page":"CNAB","title":"FastIBPM.surface_force!","text":"surface_force!(f, sol)\n\nConvert the redistributed force f_tilde back to the physical surface force f.\n\nArguments\n\nf: Output array that will store the physical surface force.\nsol: CNAB solver object containing f_tilde and grid/time info.\n\nBehavior\n\nComputes a scaling factor k = -h^N / Δt using _f_tilde_factor(sol).\nApplies the formula f .= -k * sol.f_tilde to recover the actual force on the body surface.\n\nNotes\n\nThis reverses the scaling applied in f_to_f_tilde!.\n\nReturns\n\nnothing: The physical surface force is written in-place to f.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.surface_force_sum","page":"CNAB","title":"FastIBPM.surface_force_sum","text":"surface_force_sum(sol)\n\nCompute the total hydrodynamic force exerted by the fluid on the immersed body.\n\nArguments\n\nsol: CNAB solver object containing f_tilde and grid/time info.\n\nBehavior\n\nComputes the scaling factor k = -h^N / Δt using _f_tilde_factor(sol).\nSums all entries of sol.f_tilde (the redistributed force at Lagrangian points).\nScales and flips the sign to recover the physical total force: total_force = -k * sum(sol.f_tilde).\n\nReturns\n\ntotal_force: The net physical force vector acting on the body.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.CNAB_signature","page":"CNAB","title":"FastIBPM.CNAB_signature","text":"const CNAB_signature\n\nA compile-time constant used as a unique identifier for the CNAB structure. It stores the string FastIBPM.jl:CNAB as a vector of bytes (Vector{UInt8}).\n\nThis signature can be used, for example, in type-checking, serialization, or validation routines.\n\n\n\n\n\n","category":"constant"},{"location":"cnab/#FastIBPM.save","page":"CNAB","title":"FastIBPM.save","text":"save(io::IO, sol::CNAB)\n\nSerialize the current state of a CNAB simulation and write it to the given I/O stream (e.g., a file). This allows the simulation to be saved and later restored.\n\nArguments\n\nio: An I/O stream to write the binary data to (e.g., a file handle).\nsol: The CNAB solver object containing the current simulation state.\n\nOutput\n\nNothing; writes directly to the provided I/O stream.\n\n\n\n\n\nsave(filename::AbstractString, x)\n\nSave the state of object x to a file on disk.\n\nThis function opens the file specified by filename for writing and delegates the actual saving to a user-defined save method for the object x. It serves as a wrapper to manage file I/O while preserving multiple dispatch.\n\nArguments\n\nfilename::AbstractString : Path to the file to write to.\nx                       : Object whose state will be saved.\n\nReturns\n\nNothing. The function writes the object's state to disk.\n\n\n\n\n\n","category":"function"},{"location":"cnab/#FastIBPM.load!","page":"CNAB","title":"FastIBPM.load!","text":"load!(io::IO, sol::CNAB)\n\nRestore a previously saved CNAB simulation state from an I/O stream (e.g., a binary file) into an existing solver object. This reconstructs the simulation exactly as it was when saved.\n\nArguments\n\nio: An I/O stream to read the binary data from (e.g., a file handle).\nsol: The CNAB solver object to populate with the loaded state.\n\nOutput\n\nNothing; the sol object is updated in-place with the loaded simulation state.\n\n\n\n\n\nload!(filename::AbstractString, x)\n\nLoad the state of object x from a file on disk.\n\nThis function opens the file specified by filename and delegates the actual loading to a user-defined load! method for the object x. It acts as a convenient wrapper to handle file I/O while preserving Julia's multiple dispatch semantics.\n\nArguments\n\nfilename::AbstractString : Path to the file to load from.\nx                       : Object to populate with the loaded data.\n\nReturns\n\nThe updated object x with its state loaded from the file.\n\n\n\n\n\n","category":"function"},{"location":"fft_r2r/#FFT-R2R","page":"FFT Transforms","title":"FFT R2R","text":"","category":"section"},{"location":"fft_r2r/#FastIBPM.FFT_R2R","page":"FFT Transforms","title":"FastIBPM.FFT_R2R","text":"FFT_R2R.jl\n\nProvides a real-to-real (R2R) Fast Fourier Transform (FFT) interface and implementations using FFTW.jl, with GPU/CPU support via KernelAbstractions.jl.\n\nThis module extends Julia's linear algebra interface by overloading mul! to support custom FFT-based operations for real-valued arrays.\n\nFeatures\n\nReal-to-real FFT transforms (R2R)\nCPU/GPU dispatch via KernelAbstractions\nIntegration with Julia’s LinearAlgebra API\n\n\n\n\n\n","category":"module"},{"location":"fft_r2r/#FastIBPM.FFT_R2R.plan_r2r!","page":"FFT Transforms","title":"FastIBPM.FFT_R2R.plan_r2r!","text":"plan_r2r!(A, args...; kw...)\n\nCreate a plan for a real-to-real (R2R) FFT on array A. \n\nThis function:\n\nChooses the appropriate backend (CPU/GPU) automatically.\nDelegates to _plan_r2r! for backend-specific planning.\n\nArguments\n\nA: the array to transform.\nargs...: FFTW-compatible transform arguments (e.g., type of R2R transform).\nkw...: optional keyword arguments.\n\nReturns\n\nA plan object that can be used with mul!(y, plan, x) to apply the transform efficiently.\n\nNotes\n\nOn CPU, uses FFTW.plan_r2r! with multithreading.\nIf the requested transform is not natively supported, a fallback plan (e.g., RODFT00, REDFT10) is created automatically.\n\n\n\n\n\n","category":"function"},{"location":"fft_r2r/#FastIBPM.FFT_R2R.bad_plan_r2r!","page":"FFT Transforms","title":"FastIBPM.FFT_R2R.bad_plan_r2r!","text":"bad_plan_r2r(A, args...; kw...)\n\nInternal helper to create multi-dimensional R2R FFT plans.\n\nReturns\n\nReturns a container (R2R) holding 1D FFT plans for each dimension.\n\n\n\n\n\nbad_plan_r2r!(A, ::Val{FFTW.RODFT00}, dims; kw...)\n\nCreates a plan for a type-I sine transform (RODFT00) along dimension dims of array A. Internally, it allocates staging arrays and builds an RFFT plan that emulates the desired R2R transform.\n\nArguments\n\nA: input array\n::Val{FFTW.RODFT00}: indicates the transform type\ndims: the dimension along which to apply the transform\nkw...: keyword arguments forwarded to plan_rfft\n\nReturns\n\nRODFT00 object containing the plan and internal arrays\n\n\n\n\n\nbad_plan_r2r!(A, ::Val{FFTW.REDFT10}, dims; kw...)\n\nCreates a plan for a type-II cosine transform (REDFT10) along dimension dims of array A. Internally, it allocates staging arrays and builds an RFFT plan that emulates the R2R transform.\n\nArguments\n\nA: input array\n::Val{FFTW.REDFT10}: indicates the transform type\ndims: the dimension along which to apply the transform\nkw...: keyword arguments forwarded to plan_rfft\n\nReturns\n\nREDFT10 object containing the plan and internal arrays\n\n\n\n\n\nbad_plan_r2r!(A, ::Val{FFTW.REDFT01}, dims; kw...)\n\nCreates a plan for a type-III cosine transform (REDFT01) along dimension dims of array A. Internally, it allocates staging arrays and builds an FFT plan that emulates the R2R transform.\n\nArguments\n\nA: input array\n::Val{FFTW.REDFT01}: indicates the transform type\ndims: the dimension along which to apply the transform\nkw...: keyword arguments forwarded to plan_fft\n\nReturns\n\nREDFT01 object containing the plan and internal arrays\n\n\n\n\n\n","category":"function"},{"location":"fft_r2r/#LinearAlgebra.mul!-Tuple{Any, FastIBPM.FFT_R2R.R2R, Any}","page":"FFT Transforms","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, (; p), x)\n\nApplies a multi-dimensional R2R FFT plan to an array x and stores the result in y. This overload of LinearAlgebra.mul! runs each 1D plan sequentially.\n\n\n\n\n\n","category":"method"},{"location":"fft_r2r/#FastIBPM.FFT_R2R.RODFT00","page":"FFT Transforms","title":"FastIBPM.FFT_R2R.RODFT00","text":"RODFT00{P,A,B}\n\nRepresents a type-I sine transform (FFTW's RODFT00) along a specific dimension.\n\nFields\n\ndims: dimension of the transform,\np: the FFT plan,\na, b: internal arrays for staging data.\n\n\n\n\n\n","category":"type"},{"location":"fft_r2r/#LinearAlgebra.mul!-Tuple{Any, FastIBPM.FFT_R2R.RODFT00, Any}","page":"FFT Transforms","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, (; dims, p, a, b)::RODFT00, x)\n\nApplies a type-I sine transform (RODFT00) along the specified dimension dims.  Stages x into internal array a, applies the FFT plan p to get b, and writes the processed result into y.\n\n\n\n\n\n","category":"method"},{"location":"fft_r2r/#FastIBPM.FFT_R2R.REDFT10","page":"FFT Transforms","title":"FastIBPM.FFT_R2R.REDFT10","text":"REDFT10{P,A,B}\n\nRepresents a type-II cosine transform (FFTW's REDFT10) along a specific dimension.\n\nFields\n\ndims: dimension of the transform,\np: the FFT plan,\na, b: internal arrays for staging data.\n\n\n\n\n\n","category":"type"},{"location":"fft_r2r/#LinearAlgebra.mul!-Tuple{Any, FastIBPM.FFT_R2R.REDFT10, Any}","page":"FFT Transforms","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, (; dims, p, a, b)::REDFT10, x)\n\nApplies a type-II cosine transform (REDFT10) along dimension dims.  Mirrors x, applies FFT plan p, then multiplies by a phase factor to match the transform formula.\n\n\n\n\n\n","category":"method"},{"location":"fft_r2r/#FastIBPM.FFT_R2R.REDFT01","page":"FFT Transforms","title":"FastIBPM.FFT_R2R.REDFT01","text":"REDFT01{P,A,B}\n\nRepresents a type-III cosine transform (FFTW's REDFT01) along a specific dimension.\n\nFields\n\ndims: dimension of the transform,\np: the FFT plan,\na, b: internal arrays for staging data.\n\n\n\n\n\n","category":"type"},{"location":"fft_r2r/#LinearAlgebra.mul!-Tuple{Any, FastIBPM.FFT_R2R.REDFT01, Any}","page":"FFT Transforms","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(y, (; dims, p, a, b)::REDFT01, x)\n\nApplies a type-III cosine transform (REDFT01) along dimension dims.  Pre-multiplies x by a phase factor, applies FFT plan p, and extracts the processed result into y.\n\n\n\n\n\n","category":"method"},{"location":"#FastIBPM.jl","page":"Home","title":"FastIBPM.jl","text":"Julia CFD package based on the Immersed Boundary Projection Method (IBPM) from Taira & Colonius (2007), Colonius & Taira (2008) and Goza & Colonius (2008)\n\n","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"FastIBPM.jl is a high-performance Julia package for simulating incompressible fluid flows with immersed boundaries. It provides a modular and extensible framework for fluid–structure interaction (FSI) problems using FFT-based Poisson solvers and strongly-coupled time integration schemes.\n\nKey features include:\n\nMultilevel grid hierarchy for efficiency.\nSupport for static, prescribed, and deformable bodies.\nGPU and multi-threaded support through KernelAbstractions.jl.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/NUFgroup/FastIBPM.jl\")","category":"section"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#FastIBPM.log_timestep","page":"Utilities","title":"FastIBPM.log_timestep","text":"log_timestep(i, t, wall_time)\n\nPrint a single-line status message for the current simulation step.\n\nThe message is written to stderr (so it appears in job logs) in the form: iter <i> | wall_time <seconds> | sim_time <t>.\n\nArguments\n\ni::Integer: Iteration or timestep index.\nt::Real: Simulation time (typically in flow time units).\nwall_time::Real: Elapsed wall-clock time in seconds.\n\nNotes\n\nWrites via @printf(stderr, ...) so it won’t mix with data printed to stdout.\nUse inside callbacks or your time-stepping loop.\n\nExample\n\n```julia julia> log_timestep(42, 0.125, 3.57)\n\nprints to stderr:\n\niter     42 | walltime      3.57 | simtime  0.125\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.axisunit","page":"Utilities","title":"FastIBPM.axisunit","text":"axisunit(Val(N), i)\naxisunit(Val(N))\naxisunit(I::CartesianIndex)\n\nCreates a unit vector of dimension N in the i-th direction, represented as a CartesianIndex. This is useful for moving along a specific grid axis.\n\nArguments (Method 1)\n\n::Val{N}: A Val type specifying the total number of dimensions N.\ni: The dimension for the unit vector.\n\nReturns (Method 1)\n\nCartesianIndex: A unit vector, e.g., CartesianIndex((0, 1, 0)) for N=3, i=2.\n\nArguments (Method 2)\n\n::Val{N}: A Val type specifying the dimension.\n\nReturns (Method 2)\n\nA function f(i) that creates the unit vector in direction i.\n\nArguments (Method 3)\n\nI::CartesianIndex{N}: An existing CartesianIndex used to infer the dimension N.\n\nReturns (Method 3)\n\nA function f(i) that creates the unit vector in direction i.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.OffsetTuple","page":"Utilities","title":"FastIBPM.OffsetTuple","text":"struct OffsetTuple{O,T<:Tuple}\n    x::T\nend\n\nA wrapper for a Tuple (x) that associates it with a compile-time integer offset O. This allows for indexing that starts at O instead of 1.\n\nConstructors\n\nOffsetTuple{O}(x::Tuple): Creates an OffsetTuple with offset O wrapping tuple x.\nOffsetTuple(a::Tuple): Convenience constructor. Defaults to OffsetTuple{1}(a).\nOffsetTuple(a::OffsetTuple): Returns the input a unchanged.\n\n\n\n\n\n","category":"type"},{"location":"utils/#Core.Tuple-Tuple{FastIBPM.OffsetTuple}","page":"Utilities","title":"Core.Tuple","text":"Base.Tuple(a::OffsetTuple)\n\nConverts an OffsetTuple back into a standard Tuple by unwrapping it.\n\nArguments\n\na::OffsetTuple: The offset tuple to convert.\n\nReturns\n\nTuple: The underlying tuple a.x.\n\n\n\n\n\n","category":"method"},{"location":"utils/#FastIBPM.tupleindices","page":"Utilities","title":"FastIBPM.tupleindices","text":"tupleindices(a::Tuple)\ntupleindices(a::OffsetTuple{O})\n\nReturns a tuple representing the valid indices for a.\n\nArguments\n\na::Tuple: A standard tuple.\n\nReturns (Method 1)\n\nTuple: A tuple of indices, (1, 2, ..., length(a)).\n\nArguments\n\na::OffsetTuple{O}: An offset tuple with offset O.\n\nReturns (Method 2)\n\nOffsetTuple{O}: An offset tuple of indices, (O, O+1, ..., O + length(a) - 1).\n\n\n\n\n\n","category":"function"},{"location":"utils/#Base.length-Tuple{FastIBPM.OffsetTuple}","page":"Utilities","title":"Base.length","text":"Base.length(a::OffsetTuple)\n\nReturns the length of the OffsetTuple, which is the length of the underlying tuple it wraps.\n\nArguments\n\na::OffsetTuple: The offset tuple.\n\nReturns\n\nInt: The number of elements in a.x.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.eachindex-Tuple{FastIBPM.OffsetTuple}","page":"Utilities","title":"Base.eachindex","text":"Base.eachindex(a::OffsetTuple{O})\n\nReturns an iterable range of the valid, offset-aware indices for the OffsetTuple.\n\nArguments\n\na::OffsetTuple{O}: An offset tuple with offset O.\n\nReturns\n\nUnitRange{Int}: The range O:(O + length(a) - 1).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.getindex-Tuple{FastIBPM.OffsetTuple, Integer}","page":"Utilities","title":"Base.getindex","text":"Base.getindex(a::OffsetTuple{O}, i::Integer)\n\nProvides offset-based indexing for OffsetTuple. Accesses the i-th element, where i is expected to be in the offset range (starting from O).\n\nArguments\n\na::OffsetTuple{O}: The offset tuple.\ni::Integer: The offset index to access.\n\nReturns\n\nThe element at the corresponding internal index (i - O + 1).\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.pairs-Tuple{FastIBPM.OffsetTuple}","page":"Utilities","title":"Base.pairs","text":"Base.pairs(a::OffsetTuple{O})\n\nReturns an iterator that produces offset-aware (index, value) pairs. The indices will start from the offset O.\n\nArguments\n\na::OffsetTuple{O}: The offset tuple.\n\nReturns\n\nBase.Pairs: An iterator for use in for loops.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.map-Tuple{Any, FastIBPM.OffsetTuple}","page":"Utilities","title":"Base.map","text":"Base.map(f, a::OffsetTuple{O})\n\nApplies a function f to each element of the OffsetTuple's underlying tuple, returning a new OffsetTuple with the same offset O.\n\nArguments\n\nf: The function to apply.\na::OffsetTuple{O}: The offset tuple.\n\nReturns\n\nOffsetTuple{O}: A new offset tuple containing the results of f(x) for each element x in a.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.iterate-Tuple{FastIBPM.OffsetTuple}","page":"Utilities","title":"Base.iterate","text":"Base.iterate(a::OffsetTuple)\nBase.iterate(a::OffsetTuple, state)\n\nDefines iteration for OffsetTuple. It iterates over the values of the underlying tuple, just like a standard tuple.\n\nArguments\n\na::OffsetTuple: The offset tuple to iterate over.\nstate: The iteration state (optional).\n\nReturns\n\n(value, next_state) or nothing.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Base.iterate-Tuple{FastIBPM.OffsetTuple, Any}","page":"Utilities","title":"Base.iterate","text":"Base.iterate(a::OffsetTuple)\nBase.iterate(a::OffsetTuple, state)\n\nDefines iteration for OffsetTuple. It iterates over the values of the underlying tuple, just like a standard tuple.\n\nArguments\n\na::OffsetTuple: The offset tuple to iterate over.\nstate: The iteration state (optional).\n\nReturns\n\n(value, next_state) or nothing.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Adapt.adapt_structure-Tuple{Any, FastIBPM.OffsetTuple}","page":"Utilities","title":"Adapt.adapt_structure","text":"Adapt.adapt_structure(to, a::OffsetTuple{O})\n\nExtends Adapt.jl to handle OffsetTuple. It recursively adapts the underlying tuple a.x to the target backend to (e.g., a GPU) and re-wraps the result in an OffsetTuple with the same offset O.\n\nArguments\n\nto: The target backend (e.g., CuArray).\na::OffsetTuple{O}: The offset tuple to adapt.\n\nReturns\n\nOffsetTuple{O}: A new offset tuple with its data adapted to the backend.\n\n\n\n\n\n","category":"method"},{"location":"utils/#FastIBPM._nd_tuple","page":"Utilities","title":"FastIBPM._nd_tuple","text":"_nd_tuple(a::AbstractArray)\n\nRecursively converts an N-dimensional array into a nested tuple of its elements. The nesting follows the array's dimensions.\n\nArguments\n\na::AbstractArray: The array to convert. A 1D vector will become a single tuple. A 2D matrix will become a tuple of tuples (column-wise).\n\nReturns\n\nTuple: A nested tuple structure matching the array's data.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.otheraxes","page":"Utilities","title":"FastIBPM.otheraxes","text":"otheraxes(i)\n\nGiven an axis index i (1, 2, or 3), returns the other two axes in cyclic order.\n\nArguments\n\ni::Int: The current axis index (1, 2, or 3).\n\nReturns\n\nTuple{Int, Int}: The other two axes. (e.g., i=1 returns (2, 3)).\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.axes_permutations","page":"Utilities","title":"FastIBPM.axes_permutations","text":"axes_permutations(i)\n\nGiven an axis index i, returns the permutations of the other two axes.\n\nArguments\n\ni::Int: The current axis index (1, 2, or 3).\n\nReturns\n\nTuple{Tuple{Int, Int}, Tuple{Int, Int}}: A tuple containing the forward and reverse permutations of the other two axes. (e.g., i=1 returns ((2, 3), (3, 2))).\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.Vec","page":"Utilities","title":"FastIBPM.Vec","text":"struct Vec end\n\nEmpty struct used as a tag for dispatch, likely to distinguish between different types of vector-like objects (e.g., a full 3D vector).\n\n\n\n\n\n","category":"type"},{"location":"utils/#FastIBPM.VecZ","page":"Utilities","title":"FastIBPM.VecZ","text":"struct VecZ end\n\nEmpty struct used as a tag for dispatch, likely to distinguish a Z-only component in functions like sumcross.\n\n\n\n\n\n","category":"type"},{"location":"utils/#FastIBPM.vec_kind","page":"Utilities","title":"FastIBPM.vec_kind","text":"vec_kind(::Tuple)\nvec_kind(::OffsetTuple{3,<:NTuple{1}})\n\nA dispatch function that returns a Vec or VecZ tag based on the input's type.\n\nArguments\n\n::Tuple: Matches any standard tuple.\n::OffsetTuple{3,<:NTuple{1}}: Matches a specific OffsetTuple (offset 3, 1-element).\n\nReturns\n\nVec() for a standard tuple.\nVecZ() for the specific OffsetTuple type.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.sumcross","page":"Utilities","title":"FastIBPM.sumcross","text":"sumcross(f, i::Int)\nsumcross(f, i, ::Vec, ::Vec)\nsumcross(f, i::Int, ::Vec, ::VecZ)\nsumcross(f, i, a::VecZ, b::Vec)\n\nComputes antisymmetric combinations (like cross-products or curl components) of a function f applied to 3D axis indices.\n\nThe function f is expected to take two indices, f(j, k).\n\nArguments\n\nf: A function (Int, Int) -> Value.\ni::Int: The primary axis index (1, 2, or 3).\n::Vec, ::VecZ: Tags used for dispatch to select the correct formula.\n\nReturns\n\nA value representing the antisymmetric combination.\nMethod 1 (base): f(j, k) - f(k, j) where (j, k) = otheraxes(i).\nMethod 2 (Vec, Vec): Dispatches to Method 1.\nMethod 3 (Vec, VecZ): Specialized form for i=1 or i=2.\nMethod 4 (VecZ, Vec): Negation of Method 3 with flipped arguments.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.outward","page":"Utilities","title":"FastIBPM.outward","text":"outward(dir)\n\nMaps a direction index (1 or 2) to a sign (-1 or 1).\n\noutward(1) returns -1.\noutward(2) returns 1.\n\nArguments\n\ndir::Int: The direction index (1 or 2).\n\nReturns\n\nInt: -1 or 1.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM._cycle!","page":"Utilities","title":"FastIBPM._cycle!","text":"_cycle!(a::Vector)\n\nPerforms an in-place right circular shift on a vector. The last element becomes the first.\n\nArguments\n\na::Vector: The vector to be modified in-place.\n\nReturns\n\nThe modified vector a.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.workgroup_size","page":"Utilities","title":"FastIBPM.workgroup_size","text":"const workgroup_size = Ref(64)\n\nA mutable, global reference to the workgroup size used by KernelAbstractions.jl kernels, particularly in the @loop macro.\n\nThis is a const Ref so the reference cannot be reassigned, but the value can be changed via workgroup_size[] = 128.\n\n\n\n\n\n","category":"constant"},{"location":"utils/#FastIBPM.@loop","page":"Utilities","title":"FastIBPM.@loop","text":"@loop backend (I in R) ex\n\nA macro to simplify launching parallel kernels using KernelAbstractions.jl. It automatically defines and launches a kernel that executes the expression ex over the CartesianIndices R.\n\nArguments\n\nbackend: The KernelAbstractions backend (e.g., CPU(), CUDABackend()).\n(I in R): The loop specification, where I is the index symbol and R is a CartesianIndices range.\nex: The code block (loop body) to execute for each index I.\n\n\n\n\n\n","category":"macro"},{"location":"utils/#FastIBPM._set!","page":"Utilities","title":"FastIBPM._set!","text":"_set!(b, a)\n\nPerforms a parallel copy of the contents of array a into array b, using the @loop macro. b is modified in-place.\n\nArguments\n\nb: The destination array (must be KA-compatible).\na: The source array.\n\nReturns\n\nThe modified array b.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.sum_map","page":"Utilities","title":"FastIBPM.sum_map","text":"sum_map(f, a, b)\n\nComputes sum(f(a[i], b[i]) for i in eachindex(a)) in a non-allocating manner. This avoids creating an intermediate array of results, which is more efficient, especially on GPUs.\n\nArguments\n\nf: A function that takes two arguments (f(::EltypeA, ::EltypeB)).\na: The first array.\nb: The second array.\n\nReturns\n\nThe sum of f applied element-wise to a and b.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.ArrayPool","page":"Utilities","title":"FastIBPM.ArrayPool","text":"struct ArrayPool{B,V<:AbstractVector{UInt8}}\n    backend::B\n    size::Int\n    mem::Vector{V}\n    unused::Vector{Int}\nend\n\nA memory pool for reusing large, pre-allocated memory buffers (Vector{UInt8}) to avoid the overhead of repeated allocation/deallocation, especially on GPUs.\n\nFields\n\nbackend::B: The KernelAbstractions backend (e.g., CPU()).\nsize::Int: The size in bytes of each memory block in the pool.\nmem::Vector{V}: A vector storing all allocated memory blocks.\nunused::Vector{Int}: A stack of indices into mem pointing to available blocks.\n\n\n\n\n\n","category":"type"},{"location":"utils/#FastIBPM.ArrayPoolBlock","page":"Utilities","title":"FastIBPM.ArrayPoolBlock","text":"struct ArrayPoolBlock{V<:AbstractVector{UInt8}}\n    a::V\n    index::Int\nend\n\nA wrapper for a single memory block acquired from an ArrayPool. It tracks the block's data (a) and its index in the pool's mem list to ensure it can be returned correctly.\n\n\n\n\n\n","category":"type"},{"location":"utils/#FastIBPM.acquire!","page":"Utilities","title":"FastIBPM.acquire!","text":"acquire!(pool::ArrayPool)\n\nAcquires a memory block from the ArrayPool.\n\nIf an unused block is available in the pool, it is reused. If not, a new block of pool.size bytes is allocated using pool.backend.\n\nArguments\n\npool::ArrayPool: The memory pool to acquire from.\n\nReturns\n\nArrayPoolBlock: A wrapper for the acquired memory block.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.release!","page":"Utilities","title":"FastIBPM.release!","text":"release!(pool::ArrayPool, block::ArrayPoolBlock)\n\nReturns an ArrayPoolBlock to the pool, marking it as available for reuse. Includes error checking to prevent double-releasing a block.\n\nArguments\n\npool::ArrayPool: The pool to return the block to.\nblock::ArrayPoolBlock: The block that is no longer in use.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.with_arrays","page":"Utilities","title":"FastIBPM.with_arrays","text":"with_arrays(f, pool::ArrayPool, shapes::Vararg{Any,N})\n\nA higher-order function that safely manages temporary arrays from an ArrayPool.\n\nIt acquires N blocks, creates typed arrays from them based on the shapes specification, calls f(arrays...), and then ensures all blocks are released back to the pool, even if f throws an error.\n\nArguments\n\nf: A function to call, f(array1, array2, ..., arrayN).\npool::ArrayPool: The memory pool to use.\nshapes: A vararg of (Type, shape) tuples specifying the desired element type and shape for each temporary array.\n\nReturns\n\nThe result of f(arrays...).\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM._block_array","page":"Utilities","title":"FastIBPM._block_array","text":"_block_array(block, i, T, shape)\n_block_array(block, i, T, xs)\n\nInternal helper function for with_arrays to create a typed, shaped array (or nested structure of arrays) from a raw UInt8 memory block.\n\nIt uses reinterpret and reshape to create a view into the block. The i::Ref{Int} tracks the current byte offset within the block.\n\nArguments\n\nblock::ArrayPoolBlock: The raw memory block.\ni::Ref{Int}: A mutable offset (in bytes) into the block.\nT::Type: The desired element type.\nshape: The desired shape (e.g., (32, 64)) or a nested structure of shapes.\n\nReturns\n\nA typed array view or a nested structure of array views.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM.with_arrays_like","page":"Utilities","title":"FastIBPM.with_arrays_like","text":"with_arrays_like(f, pool::ArrayPool, arrays...)\n\nA convenience wrapper for with_arrays. It allocates temporary arrays that have the same element type and shape as the provided arrays.\n\nArguments\n\nf: A function to call with the new temporary arrays.\npool::ArrayPool: The memory pool to use.\narrays...: One or more reference arrays whose eltype and shape will be matched.\n\nReturns\n\nThe result of f(temp_array1, temp_array2, ...).\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM._array_eltype","page":"Utilities","title":"FastIBPM._array_eltype","text":"_array_eltype(a::AbstractArray)\n_array_eltype(a)\n\nRecursively determines the base element type of a potentially nested structure (like a Vector of Arrays).\n\nArguments\n\na: An AbstractArray or a nested container (e.g., Tuple, Vector).\n\nReturns\n\nType: The element type of the first AbstractArray found.\n\n\n\n\n\n","category":"function"},{"location":"utils/#FastIBPM._array_shape","page":"Utilities","title":"FastIBPM._array_shape","text":"_array_shape(a::AbstractArray)\n_array_shape(a)\n\nRecursively determines the shape (from axes) of a potentially nested structure (like a Vector of Arrays).\n\nArguments\n\na: An AbstractArray or a nested container (e.g., Tuple, Vector).\n\nReturns\n\nTuple: The axes of the array.\nTuple of Tuples: A nested structure of shapes matching the input structure.\n\n\n\n\n\n","category":"function"}]
}
