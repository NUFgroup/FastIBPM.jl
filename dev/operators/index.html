<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operators · FastIBPM</title><meta name="title" content="Operators · FastIBPM"/><meta property="og:title" content="Operators · FastIBPM"/><meta property="twitter:title" content="Operators · FastIBPM"/><meta name="description" content="Documentation for FastIBPM."/><meta property="og:description" content="Documentation for FastIBPM."/><meta property="twitter:description" content="Documentation for FastIBPM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastIBPM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../problem_definition/">Problem Definition</a></li><li><a class="tocitem" href="../cnab/">CNAB</a></li><li><a class="tocitem" href="../prescribed_bodies/">Prescribed Bodies</a></li><li class="is-active"><a class="tocitem" href>Operators</a></li><li><a class="tocitem" href="../fft_r2r/">FFT Transforms</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NUFgroup/FastIBPM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NUFgroup/FastIBPM.jl/blob/main/docs/src/operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FastIBPM.nonlinear!"><a class="docstring-binding" href="#FastIBPM.nonlinear!"><code>FastIBPM.nonlinear!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonlinear!(nonlin, u, ω)</code></pre><p>Compute the nonlinear advection term in-place.</p><p>This function updates the nonlinear term array <code>nonlin</code> by evaluating the nonlinear contribution at every grid point, based on the velocity field <code>u</code> and the vorticity field <code>ω</code>. It represents the convective term the convective term (u · ∇)u = u × ω for incompressible flow.</p><p>The computation is parallelized over the grid using the appropriate backend (e.g. CPU or GPU).</p><p><strong>Arguments</strong></p><ul><li><code>nonlin</code>: array (or array of arrays) storing the nonlinear term; modified in place.</li><li><code>u</code>: velocity field.</li><li><code>ω</code>: vorticity field.</li></ul><p><strong>Returns</strong></p><p>The updated <code>nonlin</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L17-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.nonlinear"><a class="docstring-binding" href="#FastIBPM.nonlinear"><code>FastIBPM.nonlinear</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonlinear(i, u, ω, I)</code></pre><p>Compute the nonlinear advection term for component <code>i</code> at grid point <code>I</code>.</p><p>This function evaluates the local contribution of the nonlinear term the i-th component of the cross product u × ω computed using bilinear interpolation of the velocity and vorticity fields. velocity and vorticity fields. It is called internally by <a href="#FastIBPM.nonlinear!"><code>nonlinear!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>i</code>: index of the velocity component being computed.</li><li><code>u</code>: velocity field.</li><li><code>ω</code>: vorticity field.</li><li><code>I</code>: Cartesian grid index.</li></ul><p><strong>Returns</strong></p><p>The scalar nonlinear term at the specified component and grid location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L50-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.rot!"><a class="docstring-binding" href="#FastIBPM.rot!"><code>FastIBPM.rot!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rot!(ω, u; h)</code></pre><p>Compute the vorticity field <code>ω</code> from the velocity field <code>u</code> in-place.</p><p><strong>Arguments</strong></p><ul><li><code>ω</code>: Array of arrays where the computed vorticity components will be stored (mutated in-place).</li><li><code>u</code>: Array of arrays representing the velocity field.</li><li><code>h</code>: Grid spacing used for finite-difference approximation of the curl (keyword argument).</li></ul><p><strong>Description</strong></p><p>This function updates <code>ω</code> directly by looping over each component and grid index, calling <code>rot(i, u, I; h)</code> for each point.   The computation is parallelized using the available backend (CPU or GPU) for efficiency.</p><p><strong>Returns</strong></p><ul><li><code>ω</code>: The updated vorticity field (same array as input, modified in-place).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L79-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.rot"><a class="docstring-binding" href="#FastIBPM.rot"><code>FastIBPM.rot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rot(i, u, I; h)</code></pre><p>Compute the i-th component of the vorticity (curl) at a single grid point <code>I</code> from a velocity field <code>u</code>.</p><p><strong>Arguments</strong></p><ul><li><code>i</code>: Index of the vorticity component to compute (e.g., 1 for x, 2 for y).</li><li><code>u</code>: Array of arrays representing the velocity field.</li><li><code>I</code>: Cartesian index of the grid point where the curl is computed.</li><li><code>h</code>: Grid spacing used for finite-difference approximation.</li></ul><p><strong>Returns</strong></p><ul><li>Scalar value representing the i-th component of the vorticity at point <code>I</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This function computes the curl at a single point. To compute the full vorticity field over the grid, use <code>rot!(ω, u; h)</code>, which applies <code>rot</code> in-place across all grid points.</li><li>The function uses finite differences and cross-product indexing (<code>sumcross</code>) to compute the curl:</li></ul><p>(∇ × u)<em>i = sum</em>{(j,k)} (u<em>k[I] - u</em>k[I-δ(j)]) / h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L109-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.curl!"><a class="docstring-binding" href="#FastIBPM.curl!"><code>FastIBPM.curl!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">curl!(u, ψ; h)</code></pre><p>Compute the velocity field <code>u</code> as the curl of a potential field <code>ψ</code> over the entire grid.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Array of arrays representing the velocity field (updated in-place).</li><li><code>ψ</code>: Array of arrays representing the potential field.</li><li><code>h</code>: Grid spacing used for finite-difference approximation.</li></ul><p><strong>Returns</strong></p><ul><li>The updated velocity field <code>u</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This function applies the <code>curl</code> computation at every grid point in-place.</li><li>It uses finite differences and the helper function <code>curl(i, ψ, I; h)</code> to compute each component.</li><li>The <code>backend</code> is automatically chosen for parallel or GPU execution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L137-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.curl"><a class="docstring-binding" href="#FastIBPM.curl"><code>FastIBPM.curl</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">curl(i, ψ, I; h)</code></pre><p>Compute the <code>i</code>-th component of a velocity field as the curl of a scalar potential <code>ψ</code> at a specific grid point.</p><p><strong>Arguments</strong></p><ul><li><code>i</code>: Index of the velocity component to compute (e.g., 1 for x, 2 for y).</li><li><code>ψ</code>: Array of arrays representing the scalar potential field.</li><li><code>I</code>: Cartesian index of the grid point where the curl is evaluated.</li><li><code>h</code>: Grid spacing used for finite-difference approximation.</li></ul><p><strong>Returns</strong></p><ul><li>A scalar value representing the <code>i</code>-th component of the curl at grid point <code>I</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The result is divergence-free by construction.</li><li>Uses centered finite differences and <code>sumcross</code> to handle component indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L167-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.LaplacianPlan"><a class="docstring-binding" href="#FastIBPM.LaplacianPlan"><code>FastIBPM.LaplacianPlan</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct LaplacianPlan</code></pre><p>Holds the data required to compute the Laplacian efficiently in spectral space using FFTs.</p><p><strong>Fields</strong></p><ul><li><code>λ</code>: eigenvalues of the Laplacian for spectral multiplication.</li><li><code>work</code>: temporary workspace array.</li><li><code>fwd</code>: forward FFT plan.</li><li><code>inv</code>: inverse FFT plan.</li><li><code>n_logical</code>: logical size of the FFT domain.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">LaplacianPlan(ω_i, i, n)</code></pre><p>Creates a <code>LaplacianPlan</code> for a given field component <code>ω_i</code> on a grid of size <code>n</code> (e.g., <code>SVector(nx, ny)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>ω_i</code>: array representing one component of the field (e.g., vorticity).</li><li><code>i</code>: component index (1, 2, or 3 for x, y, z).</li><li><code>n</code>: grid resolution as <code>SVector{N}</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>LaplacianPlan</code> struct containing all data needed to:<ol><li>Transform the field to spectral space.</li><li>Multiply by Laplacian eigenvalues.</li><li>Transform back to physical space.</li></ol></li></ul><p><strong>Notes</strong></p><ul><li>The constructor sets up FFT plans (<code>fwd</code> and <code>inv</code>) and eigenvalues (<code>λ</code>) automatically.</li><li>The Laplacian is then applied as <code>Δu ≈ λ .* fwd(u)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L194-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.laplacian_fft_kind"><a class="docstring-binding" href="#FastIBPM.laplacian_fft_kind"><code>FastIBPM.laplacian_fft_kind</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">laplacian_fft_kind(i, nd)</code></pre><p>Return a tuple specifying the FFT type to use along each dimension of a multidimensional array for the Laplacian operator.</p><p><strong>Arguments</strong></p><ul><li><code>i</code>: The dimension index that should use a cosine transform (<code>FFTW.REDFT01</code>).</li><li><code>nd</code>: Total number of dimensions of the array.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple of length <code>nd</code> with <code>FFTW.REDFT01</code> for dimension <code>i</code> and <code>FFTW.RODFT00</code> for all other dimensions.</li></ul><p><strong>Notes</strong></p><ul><li><code>REDFT01</code> (DCT-I) is typically used for Neumann or periodic boundary conditions.</li><li><code>RODFT00</code> (DST-I) is typically used for Dirichlet (zero-value) boundary conditions.	</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L252-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.laplacian_eigvals!"><a class="docstring-binding" href="#FastIBPM.laplacian_eigvals!"><code>FastIBPM.laplacian_eigvals!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">laplacian_eigvals!(λ, i)</code></pre><p>Compute the eigenvalues of the discrete Laplacian on a multidimensional grid and store them in λ.</p><p><strong>Arguments</strong></p><ul><li>λ: Array to hold the eigenvalues (modified in-place)</li><li>i: The dimension index along which the cosine transform (DCT) is applied; other dimensions use sine transforms (DST)</li></ul><p><strong>Returns</strong></p><ul><li>The array λ filled with Laplacian eigenvalues</li></ul><p><strong>Notes</strong></p><ul><li>The computation runs in parallel on the backend associated with λ</li><li>Eigenvalues correspond to the discrete Laplacian under DCT (dimension i) and DST (other dimensions)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L272-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.laplacian_plans"><a class="docstring-binding" href="#FastIBPM.laplacian_plans"><code>FastIBPM.laplacian_plans</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">laplacian_plans(ω, n)</code></pre><p>Create a Laplacian plan for each component of a vector field ω.</p><p><strong>Arguments</strong></p><ul><li>ω: Vector field whose components require Laplacian plans</li><li>n: Grid resolution (e.g., tuple of (nx, ny) or (nx, ny, nz))</li></ul><p><strong>Returns</strong></p><ul><li>A tuple of LaplacianPlan objects, one for each component of ω</li></ul><p><strong>Notes</strong></p><ul><li>Each LaplacianPlan contains the eigenvalues and FFT plans needed for spectral Poisson solvers</li><li>Useful when different components require different FFT types due to mixed boundary conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L310-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.EigenbasisTransform"><a class="docstring-binding" href="#FastIBPM.EigenbasisTransform"><code>FastIBPM.EigenbasisTransform</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EigenbasisTransform</code></pre><p>Represents a spectral transform that applies a function <code>f</code> (e.g., inverse Laplacian) in the eigenbasis of the Laplacian. It uses precomputed Laplacian plans to efficiently apply forward and inverse FFTs, multiply by <code>f(λ)</code> in spectral space, and transform back.</p><p><strong>Fields</strong></p><ul><li><code>f</code>: Function or scalar applied to the eigenvalues.</li><li><code>plan</code>: Tuple of LaplacianPlan objects wrapped in an OffsetTuple for staggered grid alignment.</li></ul><p><strong>Constructor</strong></p><ul><li><code>EigenbasisTransform(f, plans::Tuple)</code> wraps a regular tuple of <code>LaplacianPlan</code> objects into an <code>OffsetTuple</code> automatically.  This allows you to pass a standard tuple without needing to manually construct an <code>OffsetTuple</code>.</li></ul><p><strong>Call Overloads</strong></p><ul><li><code>(X::EigenbasisTransform)(y, ω)</code> applies the transform to all components of <code>ω</code>, storing the result in <code>y</code>.</li><li><code>(X::EigenbasisTransform)(yᵢ, ωᵢ, i)</code> applies the transform to the <code>i</code>-th component using its corresponding Laplacian plan.  </li></ul><p><strong>Notes</strong></p><ul><li>Useful for spectral Poisson solvers and other operations in the Laplacian eigenbasis.</li><li>The OffsetTuple ensures proper alignment for staggered grid variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L330-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._coarse_indices"><a class="docstring-binding" href="#FastIBPM._coarse_indices"><code>FastIBPM._coarse_indices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_coarse_indices(n::NTuple{N}, loc::Edge{Dual}) where {N}</code></pre><p>Compute the index ranges for a coarser grid that is a subset of the original grid.</p><p><strong>Description</strong></p><p>This function determines which indices to retain when coarsening a field defined on edges of the dual grid.   It is used in multigrid methods to identify the portion of the grid that remains after reducing resolution.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Tuple giving the number of grid points in each dimension.</li><li><code>loc</code>: Specifies the edge location in the dual grid.</li></ul><p><strong>Returns</strong></p><p>A tuple of index ranges corresponding to the coarse grid coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L379-L394">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.multidomain_coarsen!"><a class="docstring-binding" href="#FastIBPM.multidomain_coarsen!"><code>FastIBPM.multidomain_coarsen!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidomain_coarsen!(ω², ω¹; n)</code></pre><p>Coarsen a fine-grid field ω¹ into a coarser field ω² for use in multigrid solvers.</p><p><strong>Description</strong></p><p>This function reduces the resolution of each component of a vector field by averaging fine-grid values into the coarser grid using a restriction stencil.   It runs in parallel across the computational backend and relies on <code>_coarse_indices</code> and <code>multidomain_coarsen</code> for index mapping and averaging.</p><p><strong>Arguments</strong></p><ul><li><code>ω²</code>: Output field on the coarser grid.</li><li><code>ω¹</code>: Input field on the finer grid.</li><li><code>n</code>: Tuple giving the grid resolution.</li></ul><p><strong>Returns</strong></p><p>The coarsened field <code>ω²</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L404-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.multidomain_coarsen"><a class="docstring-binding" href="#FastIBPM.multidomain_coarsen"><code>FastIBPM.multidomain_coarsen</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidomain_coarsen(i, ωᵢ, I²; n)</code></pre><p>Compute the coarse-grid value of a field component from its fine-grid representation.</p><p><strong>Description</strong></p><p>For component <code>i</code>, this function calculates the value at coarse-grid index <code>I²</code> by averaging corresponding fine-grid points using a predefined stencil.   It is used internally by <code>multidomain_coarsen!</code> to define the restriction operation.</p><p><strong>Arguments</strong></p><ul><li><code>i</code>: Component index.</li><li><code>ωᵢ</code>: Fine-grid array for the given component.</li><li><code>I²</code>: Cartesian index on the coarse grid.</li><li><code>n</code>: Tuple giving the grid resolution.</li></ul><p><strong>Returns</strong></p><p>The coarse-grid value at index <code>I²</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L432-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._coarsen_stencil"><a class="docstring-binding" href="#FastIBPM._coarsen_stencil"><code>FastIBPM._coarsen_stencil</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_coarsen_stencil(T)</code></pre><p>Return a normalized 3×3 smoothing stencil used for grid coarsening.</p><p><strong>Description</strong></p><p>This function defines a weighted averaging kernel for use in multigrid coarsening or smoothing operations.   It produces a static 3×3 matrix from <code>StaticArrays.jl</code> with higher weight at the center and symmetric lower weights around it.   The entries sum to 1, ensuring mass conservation during coarsening.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: Element type of the output matrix.</li></ul><p><strong>Returns</strong></p><p>A 3×3 static matrix of type <code>T</code> used as a normalized coarsening stencil.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L463-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._fine_indices"><a class="docstring-binding" href="#FastIBPM._fine_indices"><code>FastIBPM._fine_indices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_fine_indices(i, n, I)</code></pre><p>Return the fine-grid indices corresponding to a coarse-grid index <code>I</code>.</p><p><strong>Description</strong></p><p>This function identifies which fine-grid cells map to a given coarse-grid location, used for coarsening or restriction in multigrid solvers.   It supports both 2D and 3D cases:</p><ul><li>In 2D, it returns a single <code>CartesianIndices</code> range.</li><li>In 3D, it returns two <code>CartesianIndices</code> planes associated with the selected component <code>i</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>i</code>: Component index (used only in 3D).</li><li><code>n</code>: Tuple representing the grid size.</li><li><code>I</code>: Coarse-grid index tuple.</li></ul><p><strong>Returns</strong></p><p>A tuple of one or more <code>CartesianIndices</code> objects representing fine-grid regions corresponding to the coarse-grid index <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L489-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._fine_range"><a class="docstring-binding" href="#FastIBPM._fine_range"><code>FastIBPM._fine_range</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_fine_range(n, I)</code></pre><p>Return the range of fine-grid indices corresponding to a coarse-grid index <code>I</code> along one dimension.</p><p><strong>Description</strong></p><p>Maps a 1D coarse-grid index to the corresponding three-point region on the fine grid, assuming a 4:1 refinement ratio.   The range is centered around <code>2 * (I - n/4)</code> and includes the neighboring points at offsets <code>-1</code>, <code>0</code>, and <code>+1</code>.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Grid size along the considered dimension.</li><li><code>I</code>: Coarse-grid index.</li></ul><p><strong>Returns</strong></p><p>A <code>UnitRange</code> of three fine-grid indices corresponding to the coarse-grid index <code>I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L521-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.multidomain_interpolate!"><a class="docstring-binding" href="#FastIBPM.multidomain_interpolate!"><code>FastIBPM.multidomain_interpolate!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidomain_interpolate!(ωb, ω; n)</code></pre><p>Interpolate a fine-grid field <code>ω</code> onto boundary or ghost regions, storing results in <code>ωb</code>.</p><p><strong>Description</strong></p><p>This function computes interpolated boundary values from a fine-grid field <code>ω</code> and writes them into the corresponding boundary arrays <code>ωb</code>.   It supports both 2D and 3D cases and calls the helper function [<code>multidomain_interpolate</code>] for the actual interpolation logic.</p><p><strong>Arguments</strong></p><ul><li><code>ωb</code>: Output array for interpolated boundary values.</li><li><code>ω</code>: Input fine-grid field (e.g., vorticity).</li><li><code>n</code>: Grid size tuple, used for mapping fine-to-coarse indices.</li></ul><p><strong>Returns</strong></p><p>The updated <code>ωb</code> containing interpolated boundary values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L543-L559">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.multidomain_interpolate"><a class="docstring-binding" href="#FastIBPM.multidomain_interpolate"><code>FastIBPM.multidomain_interpolate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidomain_interpolate(ωᵢ, (i, j, k), dir, I¹; n)</code></pre><p>Interpolate values from a fine grid onto a coarser grid or boundary face.</p><p><strong>Description</strong></p><p>Defines the interpolation rule used by [<code>multidomain_interpolate!</code>].   Two methods are available:</p><ul><li><strong>2D version</strong> (<code>CartesianIndex{2}</code>): performs simple linear interpolation along one direction.</li><li><strong>3D version</strong> (<code>CartesianIndex{3}</code>): performs bilinear interpolation on a 2D plane, adjusting for component offsets.</li></ul><p><strong>Arguments</strong></p><ul><li><code>ωᵢ</code>: Component <code>i</code> of the fine-grid field.</li><li><code>(i, j, k)</code>: Index tuple defining component and orientation.</li><li><code>dir</code>: Direction index for boundary interpolation.</li><li><code>I¹</code>: Fine-grid index at which interpolation is performed.</li><li><code>n</code>: Grid size tuple.</li></ul><p><strong>Returns</strong></p><p>Interpolated scalar value for the target coarse-grid or boundary location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L573-L593">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.set_boundary!"><a class="docstring-binding" href="#FastIBPM.set_boundary!"><code>FastIBPM.set_boundary!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_boundary!(ω, ωb)</code></pre><p>Copy boundary values from a boundary buffer <code>ωb</code> into the main field <code>ω</code>.</p><p><strong>Description</strong></p><p>This function updates the field <code>ω</code> by setting its boundary regions to the corresponding values stored in <code>ωb</code>.   It is typically used after interpolation or restriction steps in multigrid or multidomain solvers to enforce consistent boundary conditions.</p><p>The operation is performed in parallel using backend-agnostic loops.</p><p><strong>Arguments</strong></p><ul><li><code>ω</code>: Main field to be updated (e.g., vorticity or velocity component arrays).</li><li><code>ωb</code>: Boundary buffer containing precomputed boundary values for each component of <code>ω</code>.</li></ul><p><strong>Returns</strong></p><p>The modified field <code>ω</code> with updated boundary values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L626-L643">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.add_laplacian_bc!"><a class="docstring-binding" href="#FastIBPM.add_laplacian_bc!"><code>FastIBPM.add_laplacian_bc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_laplacian_bc!(Lψ, factor, ψb)</code></pre><p>Apply boundary condition corrections to the Laplacian of a vector field.</p><p><strong>Description</strong></p><p>This function modifies the Laplacian <code>Lψ</code> of a field by adding contributions from boundary values in <code>ψb</code>.   It ensures that Dirichlet or Neumann boundary conditions are correctly enforced in the discrete Laplacian.</p><p><strong>Arguments</strong></p><ul><li><code>Lψ</code>: Vector of arrays representing the Laplacian of the field ψ.</li><li><code>factor</code>: Scalar multiplier for the boundary corrections.</li><li><code>ψb</code>: Boundary buffer holding Dirichlet or Neumann values at the domain boundaries.</li></ul><p><strong>Returns</strong></p><p>The modified <code>Lψ</code> with boundary corrections applied (in-place).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L658-L674">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.laplacian_bc_ii"><a class="docstring-binding" href="#FastIBPM.laplacian_bc_ii"><code>FastIBPM.laplacian_bc_ii</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">laplacian_bc_ii(ψb, i, dir, I)</code></pre><p>Compute the diagonal Laplacian boundary correction for component <code>i</code>.</p><p><strong>Description</strong></p><p>This function calculates the correction term for the Laplacian at a boundary along direction <code>dir</code> for the <code>i</code>-th component.   It uses differences of precomputed boundary values in <code>ψb</code> to enforce proper boundary conditions in the discrete Laplacian operator.</p><p><strong>Arguments</strong></p><ul><li><code>ψb</code>: Boundary buffer arrays for each component and direction.</li><li><code>i</code>: Index of the component being corrected.</li><li><code>dir</code>: Direction of the boundary (e.g., 1 = x, 2 = y, 3 = z).</li><li><code>I</code>: Cartesian index in the boundary array where the correction is computed.</li></ul><p><strong>Returns</strong></p><p>A scalar value representing the diagonal Laplacian boundary correction at the given index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L707-L724">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.multidomain_poisson!"><a class="docstring-binding" href="#FastIBPM.multidomain_poisson!"><code>FastIBPM.multidomain_poisson!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multidomain_poisson!(ω, ψ, u, ψb, grid, fft_plan)</code></pre><p>Solve Poisson equations across multiple grid levels using a multigrid-like approach.</p><p><strong>Description</strong></p><p>This function computes the solution of Poisson problems on a hierarchical set of grids.   It performs the following steps for each level:</p><ol><li>Coarsen the source term <code>ω</code> from finer to coarser grids.</li><li>Solve from coarse to fine.</li><li>Optionally compute the velocity field <code>u</code> at selected levels using <code>curl!</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>ω</code>: Vector of vector fields representing source terms at each grid level.</li><li><code>ψ</code>: Vector of potential fields to store the solution at each level.</li><li><code>u</code>: Vector of velocity fields to update via curl of <code>ψ</code>.</li><li><code>ψb</code>: Boundary buffers for the potential fields.</li><li><code>grid</code>: Grid object containing the domain size and level information.</li><li><code>fft_plan</code>: Precomputed <code>EigenbasisTransform</code> plans for spectral solves.</li></ul><p><strong>Returns</strong></p><p>The function updates <code>ψ</code> and <code>u</code> in-place with the Poisson solution and velocity field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L739-L761">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.AbstractDeltaFunc"><a class="docstring-binding" href="#FastIBPM.AbstractDeltaFunc"><code>FastIBPM.AbstractDeltaFunc</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDeltaFunc</code></pre><p>Abstract type for delta-function-like objects. Subtypes define specific delta kernels.</p><p><strong>Usage</strong></p><p>A delta function can be called on a vector <code>r</code> to evaluate the multidimensional delta:</p><pre><code class="language-julia hljs">delta(r)  # evaluates as the product of 1D delta values along each component</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L803-L813">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.DeltaYang3S"><a class="docstring-binding" href="#FastIBPM.DeltaYang3S"><code>FastIBPM.DeltaYang3S</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DeltaYang3S &lt;: AbstractDeltaFunc</code></pre><p>Smooth delta function approximation with compact support [-2, 2], following Yang et al. (2009).</p><ul><li><code>support(::DeltaYang3S) = 2</code> gives its support radius.</li><li>Calling <code>delta(r::Real)</code> evaluates the function at a real point <code>r</code> using a piecewise formula:<ul><li>|r| &lt; 1 → first formula</li><li>1 ≤ |r| &lt; 2 → second formula</li><li>|r| ≥ 2 → returns 0</li></ul></li></ul><p>The function is smooth and satisfies partition-of-unity and moment conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L820-L830">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.DeltaYang3S2"><a class="docstring-binding" href="#FastIBPM.DeltaYang3S2"><code>FastIBPM.DeltaYang3S2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DeltaYang3S2 &lt;: AbstractDeltaFunc</code></pre><p>Smoother and wider delta function than DeltaYang3S, with compact support [-3, 3].</p><ul><li><code>support(::DeltaYang3S2) = 3</code> gives its support radius.</li><li>Calling <code>delta(x::Real)</code> evaluates the function at <code>x</code> using piecewise formulas:<ul><li>r ≤ 1</li><li>1 &lt; r ≤ 2</li><li>2 &lt; r ≤ 3</li><li>r &gt; 3 → 0</li></ul></li></ul><p>Each segment uses polynomials, square roots, and arcsine terms to ensure smoothness and correct moment conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L853-L864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.Reg"><a class="docstring-binding" href="#FastIBPM.Reg"><code>FastIBPM.Reg</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Reg{D,T,N,A,M,W}
Reg(backend, T, delta, nb, Val{N})</code></pre><p>Represents a regularization operator used for interpolation and spreading based on a discrete delta function.</p><p><strong>Fields</strong></p><ul><li><code>delta</code> — the regularized delta function (a subtype of <code>AbstractDeltaFunc</code>).</li><li><code>I</code> — a matrix of index offsets defining the discrete stencil.</li><li><code>weights</code> — preallocated delta weights for each stencil point.</li></ul><p>The struct is adapted for GPU execution via <code>Adapt.@adapt_structure</code>, allowing <code>Reg</code> objects to be transferred automatically between CPU and GPU memory.</p><p><strong>Constructor</strong></p><p><code>Reg(backend, T, delta, nb, Val{N})</code> creates a regularization operator in <code>N</code> dimensions. It allocates:</p><ul><li>the stencil index matrix <code>I</code>, and</li><li>the multidimensional <code>weights</code> array whose size is determined by the support of the delta function.</li></ul><p><code>backend</code> controls where arrays are allocated (CPU or GPU), and <code>nb</code> is the number of bodies or markers for which weights are stored.</p><p>This type is typically used in immersed-boundary methods for evaluating and applying discrete delta functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L912-L939">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.update_weights!"><a class="docstring-binding" href="#FastIBPM.update_weights!"><code>FastIBPM.update_weights!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_weights!(reg, grid, xbs, ibs)</code></pre><p>Update interpolation/spreading weights for immersed boundary markers.</p><p>This function computes the stencil indices and delta-function weights used to transfer data between Lagrangian marker positions (<code>xbs</code>) and the Eulerian grid (<code>grid</code>). Only markers listed in <code>ibs</code> are updated. The result is stored in-place inside the <code>Reg</code> object <code>reg</code>.</p><p><strong>Arguments</strong></p><ul><li><code>reg::Reg</code>: Regularization structure containing delta kernel, stencil offsets, and a weight array to be filled.</li><li><code>grid::Grid{N}</code>: Eulerian grid used for mapping marker positions to grid coordinates.</li><li><code>xbs</code>: Array of marker positions (typically <code>SVector{N,Float}</code>).</li><li><code>ibs</code>: Indices of the markers to update.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>ibs</code> is empty, the function returns <code>reg</code> unchanged.</li><li>For each marker and each velocity/force component, the function:<ol><li>Computes the integer grid offset <code>I</code> nearest to the marker.</li><li>Iterates over all stencil points within the delta kernel’s support.</li><li>Evaluates the delta function at normalized offsets <code>(xb - xu) / h</code>.</li><li>Stores the resulting weights in <code>reg.weights</code>.</li></ol></li></ul><p><strong>Returns</strong></p><p>Returns the updated <code>reg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L962-L990">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.interpolate_body!"><a class="docstring-binding" href="#FastIBPM.interpolate_body!"><code>FastIBPM.interpolate_body!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interpolate_body!(ub, reg, u)</code></pre><p>Interpolate the Eulerian velocity field <code>u</code> onto the Lagrangian marker velocities <code>ub</code> using precomputed regularization stencils stored in <code>reg</code>.</p><p>This function gathers velocity values from the Eulerian grid for each marker and each velocity component, applies the corresponding delta–function weights, and stores the resulting interpolated velocities in-place in <code>ub</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ub</code>: Output array of marker velocities (e.g., <code>Vector{SVector{N,T}}</code>).</li><li><code>reg::Reg</code>: Regularization structure containing interpolation indices <code>I</code> and delta weights <code>weights</code>.</li><li><code>u</code>: Eulerian velocity field, given as an array of <code>N</code> grid arrays (<code>u[1], u[2], …</code>).</li></ul><p><strong>Notes</strong></p><ul><li>For each marker, the function loops over velocity components and computes a weighted sum of nearby grid values using the delta kernel’s support.</li><li>Uses the precomputed stencil offsets <code>reg.I</code> and weight tensors <code>reg.weights</code>, which must be updated before calling this function.</li><li>Updates <code>ub</code> in-place and also returns it.</li></ul><p><strong>Returns</strong></p><p>Updates <code>ub</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L1015-L1041">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.regularize!"><a class="docstring-binding" href="#FastIBPM.regularize!"><code>FastIBPM.regularize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">regularize!(fu, reg, fb)</code></pre><p>Spread Lagrangian forces <code>fb</code> onto the Eulerian force field <code>fu</code> using the regularization stencils stored in <code>reg</code>.</p><p>This function distributes each marker force to nearby Eulerian grid points using the delta–function weights in <code>reg.weights</code> and the corresponding index offsets in <code>reg.I</code>. The resulting Eulerian force field is written in-place in <code>fu</code>.</p><p><strong>Arguments</strong></p><ul><li><code>fu</code>: Output Eulerian force field, given as an array of <code>N</code> grids (<code>fu[1], fu[2], …</code>). All entries are reset to zero before accumulation.</li><li><code>reg::Reg</code>: Regularization structure containing interpolation/spreading indices <code>I</code> and delta weights <code>weights</code>.</li><li><code>fb</code>: Lagrangian forces, typically stored as <code>Vector{SVector{N}}</code>, one force vector per marker.</li></ul><p><strong>Notes</strong></p><ul><li>For each marker, the force components are distributed over the delta kernel’s support region.</li><li>This operation is the adjoint (transpose) of <code>interpolate_body!</code> in the immersed boundary method.</li><li>Updates <code>fu</code> in-place and also returns it.</li></ul><p><strong>Returns</strong></p><p>Updates <code>fu</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/operators.jl#L1061-L1088">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../prescribed_bodies/">« Prescribed Bodies</a><a class="docs-footer-nextpage" href="../fft_r2r/">FFT Transforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 22:51">Monday 1 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
