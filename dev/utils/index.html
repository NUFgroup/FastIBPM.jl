<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · FastIBPM</title><meta name="title" content="Utilities · FastIBPM"/><meta property="og:title" content="Utilities · FastIBPM"/><meta property="twitter:title" content="Utilities · FastIBPM"/><meta name="description" content="Documentation for FastIBPM."/><meta property="og:description" content="Documentation for FastIBPM."/><meta property="twitter:description" content="Documentation for FastIBPM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FastIBPM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../problem_definition/">Problem Definition</a></li><li><a class="tocitem" href="../cnab/">CNAB</a></li><li><a class="tocitem" href="../prescribed_bodies/">Prescribed Bodies</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../fft_r2r/">FFT Transforms</a></li><li class="is-active"><a class="tocitem" href>Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NUFgroup/FastIBPM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NUFgroup/FastIBPM.jl/blob/main/docs/src/utils.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FastIBPM.log_timestep"><a class="docstring-binding" href="#FastIBPM.log_timestep"><code>FastIBPM.log_timestep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">log_timestep(i, t, wall_time)</code></pre><p>Print a single-line status message for the current simulation step.</p><p>The message is written to <code>stderr</code> (so it appears in job logs) in the form: <code>iter &lt;i&gt; | wall_time &lt;seconds&gt; | sim_time &lt;t&gt;</code>.</p><p><strong>Arguments</strong></p><ul><li><code>i::Integer</code>: Iteration or timestep index.</li><li><code>t::Real</code>: Simulation time (typically in flow time units).</li><li><code>wall_time::Real</code>: Elapsed wall-clock time in seconds.</li></ul><p><strong>Notes</strong></p><ul><li>Writes via <code>@printf(stderr, ...)</code> so it won’t mix with data printed to <code>stdout</code>.</li><li>Use inside callbacks or your time-stepping loop.</li></ul><p><strong>Example</strong></p><p>```julia julia&gt; log_timestep(42, 0.125, 3.57)</p><p><strong>prints to stderr:</strong></p><p><strong>iter     42 | wall<em>time      3.57 | sim</em>time  0.125</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L3-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.axisunit"><a class="docstring-binding" href="#FastIBPM.axisunit"><code>FastIBPM.axisunit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">axisunit(Val(N), i)
axisunit(Val(N))
axisunit(I::CartesianIndex)</code></pre><p>Creates a unit vector of dimension <code>N</code> in the <code>i</code>-th direction, represented as a <code>CartesianIndex</code>. This is useful for moving along a specific grid axis.</p><p><strong>Arguments (Method 1)</strong></p><ul><li><code>::Val{N}</code>: A <code>Val</code> type specifying the total number of dimensions <code>N</code>.</li><li><code>i</code>: The dimension for the unit vector.</li></ul><p><strong>Returns (Method 1)</strong></p><ul><li><code>CartesianIndex</code>: A unit vector, e.g., <code>CartesianIndex((0, 1, 0))</code> for <code>N=3, i=2</code>.</li></ul><p><strong>Arguments (Method 2)</strong></p><ul><li><code>::Val{N}</code>: A <code>Val</code> type specifying the dimension.</li></ul><p><strong>Returns (Method 2)</strong></p><ul><li>A function <code>f(i)</code> that creates the unit vector in direction <code>i</code>.</li></ul><p><strong>Arguments (Method 3)</strong></p><ul><li><code>I::CartesianIndex{N}</code>: An existing <code>CartesianIndex</code> used to infer the dimension <code>N</code>.</li></ul><p><strong>Returns (Method 3)</strong></p><ul><li>A function <code>f(i)</code> that creates the unit vector in direction <code>i</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L30-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.OffsetTuple"><a class="docstring-binding" href="#FastIBPM.OffsetTuple"><code>FastIBPM.OffsetTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct OffsetTuple{O,T&lt;:Tuple}
    x::T
end</code></pre><p>A wrapper for a <code>Tuple</code> (<code>x</code>) that associates it with a compile-time integer offset <code>O</code>. This allows for indexing that starts at <code>O</code> instead of 1.</p><p><strong>Constructors</strong></p><ul><li><code>OffsetTuple{O}(x::Tuple)</code>: Creates an <code>OffsetTuple</code> with offset <code>O</code> wrapping tuple <code>x</code>.</li><li><code>OffsetTuple(a::Tuple)</code>: Convenience constructor. Defaults to <code>OffsetTuple{1}(a)</code>.</li><li><code>OffsetTuple(a::OffsetTuple)</code>: Returns the input <code>a</code> unchanged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L61-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Core.Tuple-Tuple{FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Core.Tuple-Tuple{FastIBPM.OffsetTuple}"><code>Core.Tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.Tuple(a::OffsetTuple)</code></pre><p>Converts an <code>OffsetTuple</code> back into a standard <code>Tuple</code> by unwrapping it.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple</code>: The offset tuple to convert.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: The underlying tuple <code>a.x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L82-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.tupleindices"><a class="docstring-binding" href="#FastIBPM.tupleindices"><code>FastIBPM.tupleindices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tupleindices(a::Tuple)
tupleindices(a::OffsetTuple{O})</code></pre><p>Returns a tuple representing the valid indices for <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a::Tuple</code>: A standard tuple.</li></ul><p><strong>Returns (Method 1)</strong></p><ul><li><code>Tuple</code>: A tuple of indices, <code>(1, 2, ..., length(a))</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple{O}</code>: An offset tuple with offset <code>O</code>.</li></ul><p><strong>Returns (Method 2)</strong></p><ul><li><code>OffsetTuple{O}</code>: An offset tuple of indices, <code>(O, O+1, ..., O + length(a) - 1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L95-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Base.length-Tuple{FastIBPM.OffsetTuple}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.length(a::OffsetTuple)</code></pre><p>Returns the length of the <code>OffsetTuple</code>, which is the length of the underlying tuple it wraps.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple</code>: The offset tuple.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The number of elements in <code>a.x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L118-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eachindex-Tuple{FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Base.eachindex-Tuple{FastIBPM.OffsetTuple}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.eachindex(a::OffsetTuple{O})</code></pre><p>Returns an iterable range of the valid, offset-aware indices for the <code>OffsetTuple</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple{O}</code>: An offset tuple with offset <code>O</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>UnitRange{Int}</code>: The range <code>O:(O + length(a) - 1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L131-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{FastIBPM.OffsetTuple, Integer}"><a class="docstring-binding" href="#Base.getindex-Tuple{FastIBPM.OffsetTuple, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(a::OffsetTuple{O}, i::Integer)</code></pre><p>Provides offset-based indexing for <code>OffsetTuple</code>. Accesses the <code>i</code>-th element, where <code>i</code> is expected to be in the offset range (starting from <code>O</code>).</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple{O}</code>: The offset tuple.</li><li><code>i::Integer</code>: The offset index to access.</li></ul><p><strong>Returns</strong></p><ul><li>The element at the corresponding internal index (<code>i - O + 1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L144-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.pairs-Tuple{FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Base.pairs-Tuple{FastIBPM.OffsetTuple}"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.pairs(a::OffsetTuple{O})</code></pre><p>Returns an iterator that produces offset-aware <code>(index, value)</code> pairs. The indices will start from the offset <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple{O}</code>: The offset tuple.</li></ul><p><strong>Returns</strong></p><ul><li><code>Base.Pairs</code>: An iterator for use in <code>for</code> loops.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L159-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.map-Tuple{Any, FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Base.map-Tuple{Any, FastIBPM.OffsetTuple}"><code>Base.map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.map(f, a::OffsetTuple{O})</code></pre><p>Applies a function <code>f</code> to each element of the <code>OffsetTuple</code>&#39;s underlying tuple, returning a new <code>OffsetTuple</code> with the same offset <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to apply.</li><li><code>a::OffsetTuple{O}</code>: The offset tuple.</li></ul><p><strong>Returns</strong></p><ul><li><code>OffsetTuple{O}</code>: A new offset tuple containing the results of <code>f(x)</code> for each element <code>x</code> in <code>a</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L173-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iterate-Tuple{FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Base.iterate-Tuple{FastIBPM.OffsetTuple}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iterate(a::OffsetTuple)
Base.iterate(a::OffsetTuple, state)</code></pre><p>Defines iteration for <code>OffsetTuple</code>. It iterates over the <em>values</em> of the underlying tuple, just like a standard tuple.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple</code>: The offset tuple to iterate over.</li><li><code>state</code>: The iteration state (optional).</li></ul><p><strong>Returns</strong></p><ul><li><code>(value, next_state)</code> or <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L188-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iterate-Tuple{FastIBPM.OffsetTuple, Any}"><a class="docstring-binding" href="#Base.iterate-Tuple{FastIBPM.OffsetTuple, Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iterate(a::OffsetTuple)
Base.iterate(a::OffsetTuple, state)</code></pre><p>Defines iteration for <code>OffsetTuple</code>. It iterates over the <em>values</em> of the underlying tuple, just like a standard tuple.</p><p><strong>Arguments</strong></p><ul><li><code>a::OffsetTuple</code>: The offset tuple to iterate over.</li><li><code>state</code>: The iteration state (optional).</li></ul><p><strong>Returns</strong></p><ul><li><code>(value, next_state)</code> or <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L204-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Adapt.adapt_structure-Tuple{Any, FastIBPM.OffsetTuple}"><a class="docstring-binding" href="#Adapt.adapt_structure-Tuple{Any, FastIBPM.OffsetTuple}"><code>Adapt.adapt_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Adapt.adapt_structure(to, a::OffsetTuple{O})</code></pre><p>Extends <code>Adapt.jl</code> to handle <code>OffsetTuple</code>. It recursively adapts the underlying tuple <code>a.x</code> to the target backend <code>to</code> (e.g., a GPU) and re-wraps the result in an <code>OffsetTuple</code> with the same offset <code>O</code>.</p><p><strong>Arguments</strong></p><ul><li><code>to</code>: The target backend (e.g., <code>CuArray</code>).</li><li><code>a::OffsetTuple{O}</code>: The offset tuple to adapt.</li></ul><p><strong>Returns</strong></p><ul><li><code>OffsetTuple{O}</code>: A new offset tuple with its data adapted to the backend.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L220-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._nd_tuple"><a class="docstring-binding" href="#FastIBPM._nd_tuple"><code>FastIBPM._nd_tuple</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_nd_tuple(a::AbstractArray)</code></pre><p>Recursively converts an N-dimensional array into a nested tuple of its elements. The nesting follows the array&#39;s dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>a::AbstractArray</code>: The array to convert. A 1D vector will become a single tuple. A 2D matrix will become a tuple of tuples (column-wise).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: A nested tuple structure matching the array&#39;s data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L238-L250">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.otheraxes"><a class="docstring-binding" href="#FastIBPM.otheraxes"><code>FastIBPM.otheraxes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">otheraxes(i)</code></pre><p>Given an axis index <code>i</code> (1, 2, or 3), returns the other two axes in cyclic order.</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: The current axis index (1, 2, or 3).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int, Int}</code>: The other two axes. (e.g., <code>i=1</code> returns <code>(2, 3)</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L254-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.axes_permutations"><a class="docstring-binding" href="#FastIBPM.axes_permutations"><code>FastIBPM.axes_permutations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">axes_permutations(i)</code></pre><p>Given an axis index <code>i</code>, returns the permutations of the other two axes.</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: The current axis index (1, 2, or 3).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Tuple{Int, Int}, Tuple{Int, Int}}</code>: A tuple containing the forward and reverse permutations of the other two axes. (e.g., <code>i=1</code> returns <code>((2, 3), (3, 2))</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L271-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.Vec"><a class="docstring-binding" href="#FastIBPM.Vec"><code>FastIBPM.Vec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Vec end</code></pre><p>Empty struct used as a tag for dispatch, likely to distinguish between different types of vector-like objects (e.g., a full 3D vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L285-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.VecZ"><a class="docstring-binding" href="#FastIBPM.VecZ"><code>FastIBPM.VecZ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VecZ end</code></pre><p>Empty struct used as a tag for dispatch, likely to distinguish a Z-only component in functions like <code>sumcross</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L293-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.vec_kind"><a class="docstring-binding" href="#FastIBPM.vec_kind"><code>FastIBPM.vec_kind</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vec_kind(::Tuple)
vec_kind(::OffsetTuple{3,&lt;:NTuple{1}})</code></pre><p>A dispatch function that returns a <code>Vec</code> or <code>VecZ</code> tag based on the input&#39;s type.</p><p><strong>Arguments</strong></p><ul><li><code>::Tuple</code>: Matches any standard tuple.</li><li><code>::OffsetTuple{3,&lt;:NTuple{1}}</code>: Matches a specific <code>OffsetTuple</code> (offset 3, 1-element).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vec()</code> for a standard tuple.</li><li><code>VecZ()</code> for the specific <code>OffsetTuple</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L301-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.sumcross"><a class="docstring-binding" href="#FastIBPM.sumcross"><code>FastIBPM.sumcross</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sumcross(f, i::Int)
sumcross(f, i, ::Vec, ::Vec)
sumcross(f, i::Int, ::Vec, ::VecZ)
sumcross(f, i, a::VecZ, b::Vec)</code></pre><p>Computes antisymmetric combinations (like cross-products or curl components) of a function <code>f</code> applied to 3D axis indices.</p><p>The function <code>f</code> is expected to take two indices, <code>f(j, k)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function <code>(Int, Int) -&gt; Value</code>.</li><li><code>i::Int</code>: The primary axis index (1, 2, or 3).</li><li><code>::Vec</code>, <code>::VecZ</code>: Tags used for dispatch to select the correct formula.</li></ul><p><strong>Returns</strong></p><ul><li>A value representing the antisymmetric combination.</li><li>Method 1 (base): <code>f(j, k) - f(k, j)</code> where <code>(j, k) = otheraxes(i)</code>.</li><li>Method 2 (Vec, Vec): Dispatches to Method 1.</li><li>Method 3 (Vec, VecZ): Specialized form for <code>i=1</code> or <code>i=2</code>.</li><li>Method 4 (VecZ, Vec): Negation of Method 3 with flipped arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L318-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.outward"><a class="docstring-binding" href="#FastIBPM.outward"><code>FastIBPM.outward</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">outward(dir)</code></pre><p>Maps a direction index (1 or 2) to a sign (-1 or 1).</p><ul><li><code>outward(1)</code> returns <code>-1</code>.</li><li><code>outward(2)</code> returns <code>1</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>dir::Int</code>: The direction index (1 or 2).</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: -1 or 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L355-L367">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._cycle!"><a class="docstring-binding" href="#FastIBPM._cycle!"><code>FastIBPM._cycle!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_cycle!(a::Vector)</code></pre><p>Performs an in-place right circular shift on a vector. The last element becomes the first.</p><p><strong>Arguments</strong></p><ul><li><code>a::Vector</code>: The vector to be modified in-place.</li></ul><p><strong>Returns</strong></p><ul><li>The modified vector <code>a</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L370-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.workgroup_size"><a class="docstring-binding" href="#FastIBPM.workgroup_size"><code>FastIBPM.workgroup_size</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const workgroup_size = Ref(64)</code></pre><p>A mutable, global reference to the workgroup size used by <code>KernelAbstractions.jl</code> kernels, particularly in the <code>@loop</code> macro.</p><p>This is a <code>const Ref</code> so the <em>reference</em> cannot be reassigned, but the <em>value</em> can be changed via <code>workgroup_size[] = 128</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L384-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.@loop"><a class="docstring-binding" href="#FastIBPM.@loop"><code>FastIBPM.@loop</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@loop backend (I in R) ex</code></pre><p>A macro to simplify launching parallel kernels using <code>KernelAbstractions.jl</code>. It automatically defines and launches a kernel that executes the expression <code>ex</code> over the <code>CartesianIndices</code> <code>R</code>.</p><p><strong>Arguments</strong></p><ul><li><code>backend</code>: The <code>KernelAbstractions</code> backend (e.g., <code>CPU()</code>, <code>CUDABackend()</code>).</li><li><code>(I in R)</code>: The loop specification, where <code>I</code> is the index symbol and <code>R</code> is a <code>CartesianIndices</code> range.</li><li><code>ex</code>: The code block (loop body) to execute for each index <code>I</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L395-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._set!"><a class="docstring-binding" href="#FastIBPM._set!"><code>FastIBPM._set!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_set!(b, a)</code></pre><p>Performs a parallel copy of the contents of array <code>a</code> into array <code>b</code>, using the <code>@loop</code> macro. <code>b</code> is modified in-place.</p><p><strong>Arguments</strong></p><ul><li><code>b</code>: The destination array (must be KA-compatible).</li><li><code>a</code>: The source array.</li></ul><p><strong>Returns</strong></p><ul><li>The modified array <code>b</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L436-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.sum_map"><a class="docstring-binding" href="#FastIBPM.sum_map"><code>FastIBPM.sum_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sum_map(f, a, b)</code></pre><p>Computes <code>sum(f(a[i], b[i]) for i in eachindex(a))</code> in a non-allocating manner. This avoids creating an intermediate array of results, which is more efficient, especially on GPUs.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function that takes two arguments <code>(f(::EltypeA, ::EltypeB))</code>.</li><li><code>a</code>: The first array.</li><li><code>b</code>: The second array.</li></ul><p><strong>Returns</strong></p><ul><li>The sum of <code>f</code> applied element-wise to <code>a</code> and <code>b</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L454-L468">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.ArrayPool"><a class="docstring-binding" href="#FastIBPM.ArrayPool"><code>FastIBPM.ArrayPool</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ArrayPool{B,V&lt;:AbstractVector{UInt8}}
    backend::B
    size::Int
    mem::Vector{V}
    unused::Vector{Int}
end</code></pre><p>A memory pool for reusing large, pre-allocated memory buffers (<code>Vector{UInt8}</code>) to avoid the overhead of repeated allocation/deallocation, especially on GPUs.</p><p><strong>Fields</strong></p><ul><li><code>backend::B</code>: The <code>KernelAbstractions</code> backend (e.g., <code>CPU()</code>).</li><li><code>size::Int</code>: The size <em>in bytes</em> of each memory block in the pool.</li><li><code>mem::Vector{V}</code>: A vector storing all allocated memory blocks.</li><li><code>unused::Vector{Int}</code>: A stack of indices into <code>mem</code> pointing to available blocks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L478-L494">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.ArrayPoolBlock"><a class="docstring-binding" href="#FastIBPM.ArrayPoolBlock"><code>FastIBPM.ArrayPoolBlock</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ArrayPoolBlock{V&lt;:AbstractVector{UInt8}}
    a::V
    index::Int
end</code></pre><p>A wrapper for a single memory block acquired from an <code>ArrayPool</code>. It tracks the block&#39;s data (<code>a</code>) and its <code>index</code> in the pool&#39;s <code>mem</code> list to ensure it can be returned correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L502-L511">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.acquire!"><a class="docstring-binding" href="#FastIBPM.acquire!"><code>FastIBPM.acquire!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">acquire!(pool::ArrayPool)</code></pre><p>Acquires a memory block from the <code>ArrayPool</code>.</p><p>If an unused block is available in the pool, it is reused. If not, a new block of <code>pool.size</code> bytes is allocated using <code>pool.backend</code>.</p><p><strong>Arguments</strong></p><ul><li><code>pool::ArrayPool</code>: The memory pool to acquire from.</li></ul><p><strong>Returns</strong></p><ul><li><code>ArrayPoolBlock</code>: A wrapper for the acquired memory block.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L534-L547">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.release!"><a class="docstring-binding" href="#FastIBPM.release!"><code>FastIBPM.release!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">release!(pool::ArrayPool, block::ArrayPoolBlock)</code></pre><p>Returns an <code>ArrayPoolBlock</code> to the pool, marking it as available for reuse. Includes error checking to prevent double-releasing a block.</p><p><strong>Arguments</strong></p><ul><li><code>pool::ArrayPool</code>: The pool to return the block to.</li><li><code>block::ArrayPoolBlock</code>: The block that is no longer in use.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L560-L572">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.with_arrays"><a class="docstring-binding" href="#FastIBPM.with_arrays"><code>FastIBPM.with_arrays</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">with_arrays(f, pool::ArrayPool, shapes::Vararg{Any,N})</code></pre><p>A higher-order function that safely manages temporary arrays from an <code>ArrayPool</code>.</p><p>It acquires <code>N</code> blocks, creates typed arrays from them based on the <code>shapes</code> specification, calls <code>f(arrays...)</code>, and then ensures all blocks are released back to the pool, even if <code>f</code> throws an error.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function to call, <code>f(array1, array2, ..., arrayN)</code>.</li><li><code>pool::ArrayPool</code>: The memory pool to use.</li><li><code>shapes</code>: A vararg of <code>(Type, shape)</code> tuples specifying the desired element type and shape for each temporary array.</li></ul><p><strong>Returns</strong></p><ul><li>The result of <code>f(arrays...)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L582-L599">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._block_array"><a class="docstring-binding" href="#FastIBPM._block_array"><code>FastIBPM._block_array</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_block_array(block, i, T, shape)
_block_array(block, i, T, xs)</code></pre><p>Internal helper function for <code>with_arrays</code> to create a typed, shaped array (or nested structure of arrays) from a raw <code>UInt8</code> memory block.</p><p>It uses <code>reinterpret</code> and <code>reshape</code> to create a view into the block. The <code>i::Ref{Int}</code> tracks the current byte offset within the block.</p><p><strong>Arguments</strong></p><ul><li><code>block::ArrayPoolBlock</code>: The raw memory block.</li><li><code>i::Ref{Int}</code>: A mutable offset (in bytes) into the block.</li><li><code>T::Type</code>: The desired element type.</li><li><code>shape</code>: The desired shape (e.g., <code>(32, 64)</code>) or a nested structure of shapes.</li></ul><p><strong>Returns</strong></p><ul><li>A typed array view or a nested structure of array views.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L616-L634">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM.with_arrays_like"><a class="docstring-binding" href="#FastIBPM.with_arrays_like"><code>FastIBPM.with_arrays_like</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">with_arrays_like(f, pool::ArrayPool, arrays...)</code></pre><p>A convenience wrapper for <code>with_arrays</code>. It allocates temporary arrays that have the same element type and shape as the provided <code>arrays</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function to call with the new temporary arrays.</li><li><code>pool::ArrayPool</code>: The memory pool to use.</li><li><code>arrays...</code>: One or more reference arrays whose <code>eltype</code> and <code>shape</code> will be matched.</li></ul><p><strong>Returns</strong></p><ul><li>The result of <code>f(temp_array1, temp_array2, ...)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L652-L666">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._array_eltype"><a class="docstring-binding" href="#FastIBPM._array_eltype"><code>FastIBPM._array_eltype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_array_eltype(a::AbstractArray)
_array_eltype(a)</code></pre><p>Recursively determines the base element type of a potentially nested structure (like a <code>Vector</code> of <code>Array</code>s).</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: An <code>AbstractArray</code> or a nested container (e.g., <code>Tuple</code>, <code>Vector</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Type</code>: The element type of the first <code>AbstractArray</code> found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L674-L686">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FastIBPM._array_shape"><a class="docstring-binding" href="#FastIBPM._array_shape"><code>FastIBPM._array_shape</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_array_shape(a::AbstractArray)
_array_shape(a)</code></pre><p>Recursively determines the shape (from <code>axes</code>) of a potentially nested structure (like a <code>Vector</code> of <code>Array</code>s).</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: An <code>AbstractArray</code> or a nested container (e.g., <code>Tuple</code>, <code>Vector</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: The <code>axes</code> of the array.</li><li><code>Tuple</code> of <code>Tuple</code>s: A nested structure of shapes matching the input structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NUFgroup/FastIBPM.jl/blob/be8f5d4f69cb56dfdc3566168640f5c7ce72da13/src/utils.jl#L690-L703">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fft_r2r/">« FFT Transforms</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 22:51">Monday 1 December 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
